{
  "name": "difflib",
  "version": "0.2.4",
  "description": "text diff library ported from Python's difflib module",
  "homepage": "https://github.com/qiao/difflib.js",
  "keywords": [
    "diff"
  ],
  "author": {
    "name": "Xueqiao Xu",
    "email": "xueqiaoxu@gmail.com"
  },
  "main": "./index.js",
  "dependencies": {
    "heap": ">= 0.2.0"
  },
  "devDependencies": {
    "coffee-script": ">= 1.3.0",
    "mocha": ">= 1.0.1",
    "should": ">= 0.6.0",
    "browserify": ">= 1.10.4",
    "uglify-js": ">= 1.2.5"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/qiao/difflib.js.git"
  },
  "licenses": [
    {
      "type": "PSF",
      "url": "http://docs.python.org/license.html"
    }
  ],
  "readme": "Difflib.js\n==========\n\nA JavaScript module which provides classes and functions for comparing sequences. It can be used for example, for comparing files, and can produce difference information in various formats, including context and unified diffs. Ported from Python's [difflib](http://docs.python.org/library/difflib.html) module.\n\nInstallation\n------------\n\n#### Browser\n\nTo use it in the browser, you may download the [minified js file](https://github.com/qiao/difflib.js/raw/master/dist/difflib-browser.js) and include it in your webpage.\n\n```html\n<script type=\"text/javascript\" src=\"./difflib-browser.js\"></script>\n```\n\n#### Node.js\n\nFor Node.js, you can install it using Node Package Manager (npm):\n\n```bash\nnpm install difflib\n```\n\nThen, in your script:\n\n```js\nvar difflib = require('difflib');\n```\n\nQuick Examples\n--------------\n\n1. contextDiff\n\n    ```js\n    >>> s1 = ['bacon\\n', 'eggs\\n', 'ham\\n', 'guido\\n']\n    >>> s2 = ['python\\n', 'eggy\\n', 'hamster\\n', 'guido\\n']\n    >>> difflib.contextDiff(s1, s2, {fromfile:'before.py', tofile:'after.py'})\n    [ '*** before.py\\n',\n      '--- after.py\\n',\n      '***************\\n',\n      '*** 1,4 ****\\n',\n      '! bacon\\n',\n      '! eggs\\n',\n      '! ham\\n',\n      '  guido\\n',\n      '--- 1,4 ----\\n',\n      '! python\\n',\n      '! eggy\\n',\n      '! hamster\\n',\n      '  guido\\n' ]\n    ```\n\n2. unifiedDiff\n\n    ```js\n    >>> difflib.unifiedDiff('one two three four'.split(' '),\n    ...                     'zero one tree four'.split(' '), {\n    ...                       fromfile: 'Original'\n    ...                       tofile: 'Current',\n    ...                       fromfiledate: '2005-01-26 23:30:50',\n    ...                       tofiledate: '2010-04-02 10:20:52',\n    ...                       lineterm: ''\n    ...                     })\n    [ '--- Original\\t2005-01-26 23:30:50',\n      '+++ Current\\t2010-04-02 10:20:52',\n      '@@ -1,4 +1,4 @@',\n      '+zero',\n      ' one',\n      '-two',\n      '-three',\n      '+tree',\n      ' four' ]\n    ```\n\n\n3. ndiff\n\n    ```js\n    >>> a = ['one\\n', 'two\\n', 'three\\n']\n    >>> b = ['ore\\n', 'tree\\n', 'emu\\n']\n    >>> difflib.ndiff(a, b)\n    [ '- one\\n',\n      '?  ^\\n',\n      '+ ore\\n',\n      '?  ^\\n',\n      '- two\\n',\n      '- three\\n',\n      '?  -\\n',\n      '+ tree\\n',\n      '+ emu\\n' ]\n    ```\n\n4. ratio\n\n    ```js\n    >>> s = new difflib.SequenceMatcher(null, 'abcd', 'bcde');\n    >>> s.ratio();\n    0.75\n    >>> s.quickRatio();\n    0.75\n    >>> s.realQuickRatio();\n    1.0\n    ```\n\n5. getOpcodes\n\n    ```js\n    >>> s = new difflib.SequenceMatcher(null, 'qabxcd', 'abycdf');\n    >>> s.getOpcodes();\n    [ [ 'delete'  , 0 , 1 , 0 , 0 ] ,\n      [ 'equal'   , 1 , 3 , 0 , 2 ] ,\n      [ 'replace' , 3 , 4 , 2 , 3 ] ,\n      [ 'equal'   , 4 , 6 , 3 , 5 ] ,\n      [ 'insert'  , 6 , 6 , 5 , 6 ] ]\n    ```\n\n6. getCloseMatches\n\n    ```js\n    >>> difflib.getCloseMatches('appel', ['ape', 'apple', 'peach', 'puppy'])\n    ['apple', 'ape']\n    ```\n\nDocumentation\n-------------\n\n* [SequenceMatcher](#SequenceMatcher)\n\n    * [setSeqs](#setSeqs)\n    * [setSeq1](#setSeq1)\n    * [setSeq2](#setSeq2)\n    * [findLongestMatch](#findLongestMatch)\n    * [getMatchingBlocks](#getMatchingBlocks)\n    * [getOpcodes](#getOpcodes)\n    * [getGroupedOpcodes](#getGroupedOpcodes)\n    * [ratio](#ratio)\n    * [quickRatio](#quickRatio)\n    * [realQuickRatio](#realQuickRatio)\n\n* [Differ](#Differ)\n\n    * [compare](#compare)\n\n* [contextDiff](#contextDiff)\n* [getCloseMatches](#getCloseMatches)\n* [ndiff](#ndiff)\n* [restore](#restore)\n* [unifiedDiff](#unifiedDiff)\n* [IS_LINE_JUNK](#IS_LINE_JUNK)\n* [IS_CHARACTER_JUNK](#IS_CHARACTER_JUNK)\n\n\n<a name=\"SequenceMatcher\" />\n### *class* difflib.**SequenceMatcher**([isjunk[, a[, b[, autojunk=true]]]])\n\nThis is a flexible class for comparing pairs of sequences of any type.\n\nOptional argument *isjunk* must be **null** (the default) or a one-argument function\nthat takes a sequence element and returns true if and only if the element is\n\"junk\" and should be ignored. \n\nPassing **null** for *isjunk* is equivalent to passing\n\n```js\nfunction(x) { return false; }; \n```\n\nin other words, no elements are ignored. \n\nFor example, pass:\n\n```js\nfunction(x) { return x == ' ' || x == '\\t'; }\n```\n\nif you're comparing lines as sequences of characters, \nand don’t want to synch up on blanks or hard tabs.\n\nThe optional arguments *a* and *b* are sequences to be compared;\nboth default to empty strings.\n\nThe optional argument *autojunk* can be used to disable the \nautomatic junk heuristic, which automatically treats certain sequence items as junk.\n\n\n<a name=\"setSeqs\" />\n#### setSeqs(a, b)\n\nSet the two sequences to be compared.\n\nSequenceMatcher computes and caches detailed information about the second\nsequence, so if you want to compare one sequence against many sequences,\nuse [setSeq2()](#setSeq2) to set the commonly used sequence once and call \n[setSeq1()](#setSeq1) repeatedly, once for each of the other sequences.\n\n<a name=\"setSeq1\" />\n#### setSeq1(a)\n\nSet the first sequence to be compared. The second sequence to be compared is not changed.\n\n<a name=\"setSeq2\" />\n#### setSeq2(a)\n\nSet the second sequence to be compared. The first sequence to be compared is not changed.\n\n<a name=\"findLongestMatch\" />\n#### findLongestMatch(alo, ahi, blo, bhi)\n\nFind longest matching block in `a[alo:ahi]` and `b[blo:bhi]`.\n\nIf *isjunk* was omitted or null, *findLongestMatch()* returns `[i, j, k]` such that \n`a[i:i+k]` is equal to `b[j:j+k]`, where `alo <= i <= i+k <= ahi` and \n`blo <= j <= j+k <= bhi`. \nFor all `[i', j', k']` meeting those conditions, the additional conditions `k >= k'`, \n`i <= i'`, and if `i == i'`, `j <= j'` are also met. \nIn other words, of all maximal matching blocks, return one that starts earliest in *a*,\nand of all those maximal matching blocks that start earliest in *a*, \nreturn the one that starts earliest in *b*.\n\n```js\n>>> s = new difflib.SequenceMatcher(null, \" abcd\", \"abcd abcd\");\n>>> s.findLongestMatch(0, 5, 0, 9);\n[0, 4, 5]\n```\n\nIf *isjunk* was provided, first the longest matching block is determined\nas above, but with the additional restriction that no junk element appears\nin the block. \nThen that block is extended as far as possible by matching (only) junk \nelements on both sides. So the resulting block never matches on junk \nexcept as identical junk happens to be adjacent to an interesting match.\n\nHere's the same example as before, but considering blanks to be junk. \nThat prevents `' abcd'` from matching the `' abcd'` at the tail end of \nthe second sequence directly. \nInstead only the `'abcd'` can match, and matches the leftmost `'abcd'` \nin the second sequence:\n\n```js\n>>> s = new difflib.SequenceMatcher(function(x) {return x == ' ';}, \" abcd\", \"abcd abcd\")\n>>> s.findLongestMatch(0, 5, 0, 9)\n[1, 0, 4]\n```\n\nIf no blocks match, this returns `[alo, blo, 0]`.\n\n\n<a name=\"getMatchingBlocks\" />\n#### getMatchingBlocks()\n\nReturn list of triples describing matching subsequences. \nEach triple is of the form `[i, j, n]`, and means that `a[i:i+n] == b[j:j+n]`. \nThe triples are monotonically increasing in *i* and *j*.\n\nThe last triple is a dummy, and has the value `[a.length, b.length, 0]`.\nIt is the only triple with `n == 0`. If `[i, j, n]` and `[i', j', n']` \nare adjacent triples in the list, and the second is not the last triple \nin the list, then `i+n != i'` or `j+n != j'`; \nin other words, adjacent triples always describe non-adjacent equal blocks.\n\n```js\n>>> s = new difflib.SequenceMatcher(null, \"abxcd\", \"abcd\")\n>>> s.getMatchingBlocks()\n[ [0, 0, 2], [3, 2, 2], [5, 4, 0] ]\n```\n\n<a name=\"getOpcodes\" />\n#### getOpcodes()\n\nReturn list of 5-tuples describing how to turn a into b. \nEach tuple is of the form `[tag, i1, i2, j1, j2]`. \nThe first tuple has `i1 == j1 == 0`, and remaining tuples \nhave *i1* equal to the *i2* from the preceding tuple, \nand, likewise, *j1* equal to the previous *j2*.\n\nThe tag values are strings, with these meanings:\n\n    Value       Meaning\n\n    'replace'   a[i1:i2] should be replaced by b[j1:j2].\n    'delete'    a[i1:i2] should be deleted. Note that j1 == j2 in this case.\n    'insert'    b[j1:j2] should be inserted at a[i1:i1]. Note that i1 == i2 in this case.\n    'equal'     a[i1:i2] == b[j1:j2] (the sub-sequences are equal).\n\n```js\n>>> s = new difflib.SequenceMatcher(null, 'qabxcd', 'abycdf');\n>>> s.getOpcodes();\n[ [ 'delete'  , 0 , 1 , 0 , 0 ] ,\n  [ 'equal'   , 1 , 3 , 0 , 2 ] ,\n  [ 'replace' , 3 , 4 , 2 , 3 ] ,\n  [ 'equal'   , 4 , 6 , 3 , 5 ] ,\n  [ 'insert'  , 6 , 6 , 5 , 6 ] ]\n```\n\n<a name=\"getGroupedOpcodes\" />\n#### getGroupedOpcodes([n])\n\nReturn a list groups with upto n (default is 3) lines of context.\nEach group is in the same format as returned by [getOpcodes()](#getOpcodes).\n\n<a name=\"ratio\" />\n#### ratio()\n\nReturn a measure of the sequences’ similarity as a float in the range [0, 1].\n\nWhere T is the total number of elements in both sequences, \nand M is the number of matches, this is 2.0*M / T. \nNote that this is `1.0` if the sequences are identical, \nand `0.0` if they have nothing in common.\n\nThis is expensive to compute if [getMatchingBlocks()](#getMatchingBlocks) or \n[getOpcodes()](#getOpcodes) hasn’t already been called, in which case \nyou may want to try [quickRatio()](#quickRatio) or \n[realQuickRatio()](#realQuickRatio) first to get an upper bound.\n\n<a name=\"quickRatio\" />\n#### quickRatio()\n\nReturn an upper bound on ratio() relatively quickly.\n\n<a name=\"realQuickRatio\" />\n#### realQuickRatio()\n\nReturn an upper bound on ratio() very quickly.\n\n```js\n>>> s = new difflib.SequenceMatcher(null, 'abcd', 'bcde');\n>>> s.ratio();\n0.75\n>>> s.quickRatio();\n0.75\n>>> s.realQuickRatio();\n1.0\n```\n\n<a name=\"Differ\" />\n### *class* difflib.**Differ**([linejunk[, charjunk]])\n\nThis is a class for comparing sequences of lines of text, \nand producing human-readable differences or deltas. \nDiffer uses [SequenceMatcher](#SequenceMatcher) both to compare \nsequences of lines, and to compare sequences of characters within \nsimilar (near-matching) lines.\n\nEach line of a Differ delta begins with a two-letter code:\n\n    Code    Meaning\n    '- '    line unique to sequence 1\n    '+ '    line unique to sequence 2\n    '  '    line common to both sequences\n    '? '    line not present in either input sequence\n\nLines beginning with `?` attempt to guide the eye to intraline differences, \nand were not present in either input sequence. \nThese lines can be confusing if the sequences contain tab characters.\n\nOptional parameters *linejunk* and *charjunk* are for filter functions (or **null**):\n\n*linejunk*: A function that accepts a single string argument, \nand returns true if the string is junk. \nThe default is **null**, meaning that no line is considered junk.\n\n*charjunk*: A function that accepts a single character argument \n(a string of length 1), and returns true if the character is junk. \nThe default is *null*, meaning that no character is considered junk.\n\n<a name=\"compare\" />\n#### compare(a, b)\n\nCompare two sequences of lines, and generate the delta (a sequence of lines).\n\nEach sequence must contain individual single-line strings ending with newlines.\n\n```js\n>>> d = new difflib.Differ()\n>>> d.compare(['one\\n', 'two\\n', 'three\\n'],\n...           ['ore\\n', 'tree\\n', 'emu\\n'])\n[ '- one\\n',\n  '?  ^\\n',\n  '+ ore\\n',\n  '?  ^\\n',\n  '- two\\n',\n  '- three\\n',\n  '?  -\\n',\n  '+ tree\\n',\n  '+ emu\\n' ]\n```\n\n<a name=\"contextDiff\" />\n### difflib.**contextDiff**(a, b, options)\n\nCompare *a* and *b* (lists of strings); \nreturn the delta lines in context diff format.\n\noptions:\n\n* fromfile\n* tofile\n* fromfiledate\n* tofiledate\n* n\n* lineterm\n\nContext diffs are a compact way of showing just the lines that \nhave changed plus a few lines of context. The changes are shown in a \nbefore/after style. \nThe number of context lines is set by n which defaults to three.\n\nBy default, the diff control lines (those with `***` or `---`) are created \nwith a trailing newline. \n\nFor inputs that do not have trailing newlines, set the lineterm argument \nto `\"\"` so that the output will be uniformly newline free.\n\nThe context diff format normally has a header for filenames and modification\ntimes. Any or all of these may be specified using strings for *fromfile*, \n*tofile*, *fromfiledate*, and *tofiledate*. \nThe modification times are normally expressed in the ISO 8601 format. \nIf not specified, the strings default to blanks.\n\n```js\n>>> var s1 = ['bacon\\n', 'eggs\\n', 'ham\\n', 'guido\\n']\n>>> var s2 = ['python\\n', 'eggy\\n', 'hamster\\n', 'guido\\n']\n>>> difflib.contextDiff(s1, s2, {fromfile:'before.py', tofile:'after.py'})\n[ '*** before.py\\n',\n  '--- after.py\\n',\n  '***************\\n',\n  '*** 1,4 ****\\n',\n  '! bacon\\n',\n  '! eggs\\n',\n  '! ham\\n',\n  '  guido\\n',\n  '--- 1,4 ----\\n',\n  '! python\\n',\n  '! eggy\\n',\n  '! hamster\\n',\n  '  guido\\n' ]\n```\n\n<a name=\"getCloseMatches\" />\n### difflib.*getCloseMatches*(word, possibilities\\[, n\\]\\[, cutoff\\])\n\nReturn a list of the best “good enough” matches. \n*word* is a sequence for which close matches are desired \n(typically a string), and *possibilities* is a list of sequences against \nwhich to match word (typically a list of strings).\n\nOptional argument *n* (default 3) is the maximum number of close \nmatches to return; *n* must be greater than 0.\n\nOptional argument *cutoff* (default 0.6) is a float in the range \n[0, 1]. \nPossibilities that don’t score at least that similar to word are ignored.\n\nThe best (no more than n) matches among the possibilities are \nreturned in a list, sorted by similarity score, most similar first.\n\n```js\n>>> difflib.getCloseMatches('appel', ['ape', 'apple', 'peach', 'puppy'])\n['apple', 'ape']\n```\n\n<a name=\"ndiff\" />\n### difflib.**ndiff**(a, b\\[, linejunk\\]\\[, charjunk\\])\n\nCompare *a* and b (lists of strings); \nreturn Differ-style delta lines\n\nOptional keyword parameters *linejunk* and *charjunk* are for \nfilter functions (or **null**):\n\n*linejunk*: A function that accepts a single string argument, \nand returns true if the string is junk, or false if not. \nThe default is (*null*).\n\n*charjunk*: A function that accepts a character (a string of length 1),\nand returns if the character is junk, or false if not. The default is \nmodule-level function [IS_CHARACTER_JUNK()](#IS_CHARACTER_JUNK), \nwhich filters out whitespace characters (a blank or tab; note: \nbad idea to include newline in this!).\n\n```js\n>>> a = ['one\\n', 'two\\n', 'three\\n']\n>>> b = ['ore\\n', 'tree\\n', 'emu\\n']\n>>> difflib.ndiff(a, b)\n[ '- one\\n',\n  '?  ^\\n',\n  '+ ore\\n',\n  '?  ^\\n',\n  '- two\\n',\n  '- three\\n',\n  '?  -\\n',\n  '+ tree\\n',\n  '+ emu\\n' ]\n```\n\n<a name=\"restore\" />\n### difflib.**restore**(sequence, which)\n\nReturn one of the two sequences that generated a delta.\n\nGiven a sequence produced by Differ.compare() or ndiff(), \nextract lines originating from file 1 or 2 (parameter which), stripping off line prefixes.\n\n```js\n>>> a = ['one\\n', 'two\\n', 'three\\n']\n>>> b = ['ore\\n', 'tree\\n', 'emu\\n']\n>>> diff = difflib.ndiff(a, b)\n>>> difflib.restore(diff, 1)\n[ 'one\\n',\n  'two\\n',\n  'three\\n' ]\n>>> restore(diff, 2)\n[ 'ore\\n',\n  'tree\\n',\n  'emu\\n' ]\n```\n\n<a name=\"unifiedDiff\" />\n### difflib.**unifiedDiff**(a, b, options)\n\nCompare a and b (lists of strings); \nreturn delta lines in unified diff format.\n\noptions:\n\n* fromfile\n* tofile\n* fromfiledate\n* tofiledate\n* n\n* lineterm\n\nUnified diffs are a compact way of showing just the lines that have \nchanged plus a few lines of context. \nThe changes are shown in a inline style (instead of separate before/after \nblocks). \nThe number of context lines is set by n which defaults to three.\n\nBy default, the diff control lines (those with `---`, `+++`, or `@@`) are \ncreated with a trailing newline. \n\nFor inputs that do not have trailing newlines, set the lineterm argument \nto `\"\"` so that the output will be uniformly newline free.\n\nThe context diff format normally has a header for filenames and modification\ntimes. Any or all of these may be specified using strings for *fromfile*, \n*tofile*, *fromfiledate*, and *tofiledate*. \nThe modification times are normally expressed in the ISO 8601 format.\nIf not specified, the strings default to blanks.\n\n```js\n>>> difflib.unifiedDiff('one two three four'.split(' '),\n...                     'zero one tree four'.split(' '), {\n...                       fromfile: 'Original'\n...                       tofile: 'Current',\n...                       fromfiledate: '2005-01-26 23:30:50',\n...                       tofiledate: '2010-04-02 10:20:52',\n...                       lineterm: ''\n...                     })\n[ '--- Original\\t2005-01-26 23:30:50',\n  '+++ Current\\t2010-04-02 10:20:52',\n  '@@ -1,4 +1,4 @@',\n  '+zero',\n  ' one',\n  '-two',\n  '-three',\n  '+tree',\n  ' four' ]\n```\n\n\n<a name=\"IS_LINE_JUNK\" />\n### difflib.**IS\\_LINE\\_JUNK**(line)\n\nReturn true for ignorable lines. The line line is ignorable if *line* is \nblank or contains a single `'#'`, otherwise it is not ignorable.\n\n<a name=\"IS_CHARACTER_JUNK\" />\n### difflib.**IS\\_CHARACTER\\_JUNK**(ch)\n\nReturn true for ignorable characters. The character *ch* is ignorable if ch\nis a space or tab, otherwise it is not ignorable. \nUsed as a default for parameter charjunk in [ndiff()](#ndiff).\n\n\nLicense\n-------\n\nPorted by Xueqiao Xu &lt;xueqiaoxu@gmail.com&gt;\n\nPSF LICENSE AGREEMENT FOR PYTHON 2.7.2\n\n1. This LICENSE AGREEMENT is between the Python Software Foundation (“PSF”), and the Individual or Organization (“Licensee”) accessing and otherwise using Python 2.7.2 software in source or binary form and its associated documentation.\n2. Subject to the terms and conditions of this License Agreement, PSF hereby grants Licensee a nonexclusive, royalty-free, world-wide license to reproduce, analyze, test, perform and/or display publicly, prepare derivative works, distribute, and otherwise use Python 2.7.2 alone or in any derivative version, provided, however, that PSF’s License Agreement and PSF’s notice of copyright, i.e., “Copyright © 2001-2012 Python Software Foundation; All Rights Reserved” are retained in Python 2.7.2 alone or in any derivative version prepared by Licensee.\n3. In the event Licensee prepares a derivative work that is based on or incorporates Python 2.7.2 or any part thereof, and wants to make the derivative work available to others as provided herein, then Licensee hereby agrees to include in any such work a brief summary of the changes made to Python 2.7.2.\n4. PSF is making Python 2.7.2 available to Licensee on an “AS IS” basis. PSF MAKES NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED. BY WAY OF EXAMPLE, BUT NOT LIMITATION, PSF MAKES NO AND DISCLAIMS ANY REPRESENTATION OR WARRANTY OF MERCHANTABILITY OR FITNESS FOR ANY PARTICULAR PURPOSE OR THAT THE USE OF PYTHON 2.7.2 WILL NOT INFRINGE ANY THIRD PARTY RIGHTS.\n5. PSF SHALL NOT BE LIABLE TO LICENSEE OR ANY OTHER USERS OF PYTHON 2.7.2 FOR ANY INCIDENTAL, SPECIAL, OR CONSEQUENTIAL DAMAGES OR LOSS AS A RESULT OF MODIFYING, DISTRIBUTING, OR OTHERWISE USING PYTHON 2.7.2, OR ANY DERIVATIVE THEREOF, EVEN IF ADVISED OF THE POSSIBILITY THEREOF.\n6. This License Agreement will automatically terminate upon a material breach of its terms and conditions.\n7. Nothing in this License Agreement shall be deemed to create any relationship of agency, partnership, or joint venture between PSF and Licensee. This License Agreement does not grant permission to use PSF trademarks or trade name in a trademark sense to endorse or promote products or services of Licensee, or any third party.\n8. By copying, installing or otherwise using Python 2.7.2, Licensee agrees to be bound by the terms and conditions of this License Agreement.\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/qiao/difflib.js/issues"
  },
  "_id": "difflib@0.2.4",
  "dist": {
    "shasum": "cca1650524868560305d014215d7b61e4fb88e4b"
  },
  "_from": "difflib@~0.2.1",
  "_resolved": "https://registry.npmjs.org/difflib/-/difflib-0.2.4.tgz"
}
