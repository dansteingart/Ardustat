Ext.data.JsonP.Autolinker_MatchValidator({"tagname":"class","name":"Autolinker.MatchValidator","autodetected":{},"files":[{"filename":"MatchValidator.js","href":"MatchValidator.html#Autolinker-MatchValidator"}],"private":true,"extends":null,"members":[{"name":"hasFullProtocolRegex","tagname":"property","owner":"Autolinker.MatchValidator","id":"property-hasFullProtocolRegex","meta":{"private":true}},{"name":"hasProtocolPrefixRegex","tagname":"property","owner":"Autolinker.MatchValidator","id":"property-hasProtocolPrefixRegex","meta":{"private":true}},{"name":"hasWordCharAfterProtocolRegex","tagname":"property","owner":"Autolinker.MatchValidator","id":"property-hasWordCharAfterProtocolRegex","meta":{"private":true}},{"name":"invalidProtocolRelMatchRegex","tagname":"property","owner":"Autolinker.MatchValidator","id":"property-invalidProtocolRelMatchRegex","meta":{"private":true}},{"name":"isInvalidProtocolRelativeMatch","tagname":"method","owner":"Autolinker.MatchValidator","id":"method-isInvalidProtocolRelativeMatch","meta":{"private":true}},{"name":"isValidMatch","tagname":"method","owner":"Autolinker.MatchValidator","id":"method-isValidMatch","meta":{}},{"name":"urlMatchDoesNotHaveAtLeastOneWordChar","tagname":"method","owner":"Autolinker.MatchValidator","id":"method-urlMatchDoesNotHaveAtLeastOneWordChar","meta":{"private":true}},{"name":"urlMatchDoesNotHaveProtocolOrDot","tagname":"method","owner":"Autolinker.MatchValidator","id":"method-urlMatchDoesNotHaveProtocolOrDot","meta":{"private":true}}],"alternateClassNames":[],"aliases":{},"id":"class-Autolinker.MatchValidator","short_doc":"Used by Autolinker to filter out false positives from the Autolinker.matcherRegex. ...","component":false,"superclasses":[],"subclasses":[],"mixedInto":[],"mixins":[],"parentMixins":[],"requires":[],"uses":[],"html":"<div><pre class=\"hierarchy\"><h4>Files</h4><div class='dependency'><a href='source/MatchValidator.html#Autolinker-MatchValidator' target='_blank'>MatchValidator.js</a></div></pre><div class='doc-contents'><div class='rounded-box private-box'><p><strong>NOTE:</strong> This is a private utility class for internal use by the framework. Don't rely on its existence.</p></div><p>Used by Autolinker to filter out false positives from the <a href=\"#!/api/Autolinker-property-matcherRegex\" rel=\"Autolinker-property-matcherRegex\" class=\"docClass\">Autolinker.matcherRegex</a>.</p>\n\n<p>Due to the limitations of regular expressions (including the missing feature of look-behinds in JS regular expressions),\nwe cannot always determine the validity of a given match. This class applies a bit of additional logic to filter out any\nfalse positives that have been matched by the <a href=\"#!/api/Autolinker-property-matcherRegex\" rel=\"Autolinker-property-matcherRegex\" class=\"docClass\">Autolinker.matcherRegex</a>.</p>\n</div><div class='members'><div class='members-section'><div class='definedBy'>Defined By</div><h3 class='members-title icon-property'>Properties</h3><div class='subsection'><div id='property-hasFullProtocolRegex' class='member first-child not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='Autolinker.MatchValidator'>Autolinker.MatchValidator</span><br/><a href='source/MatchValidator.html#Autolinker-MatchValidator-property-hasFullProtocolRegex' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Autolinker.MatchValidator-property-hasFullProtocolRegex' class='name expandable'>hasFullProtocolRegex</a> : RegExp<span class=\"signature\"><span class='private' >private</span></span></div><div class='description'><div class='short'>Regex to test for a full protocol, with the two trailing slashes. ...</div><div class='long'><p>Regex to test for a full protocol, with the two trailing slashes. Ex: 'http://'</p>\n<p>Defaults to: <code>/^[A-Za-z]{3,9}:\\/\\//</code></p></div></div></div><div id='property-hasProtocolPrefixRegex' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='Autolinker.MatchValidator'>Autolinker.MatchValidator</span><br/><a href='source/MatchValidator.html#Autolinker-MatchValidator-property-hasProtocolPrefixRegex' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Autolinker.MatchValidator-property-hasProtocolPrefixRegex' class='name expandable'>hasProtocolPrefixRegex</a> : RegExp<span class=\"signature\"><span class='private' >private</span></span></div><div class='description'><div class='short'>Regex to test for a protocol prefix, such as 'mailto:' ...</div><div class='long'><p>Regex to test for a protocol prefix, such as 'mailto:'</p>\n<p>Defaults to: <code>/^[A-Za-z]{3,9}:/</code></p></div></div></div><div id='property-hasWordCharAfterProtocolRegex' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='Autolinker.MatchValidator'>Autolinker.MatchValidator</span><br/><a href='source/MatchValidator.html#Autolinker-MatchValidator-property-hasWordCharAfterProtocolRegex' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Autolinker.MatchValidator-property-hasWordCharAfterProtocolRegex' class='name expandable'>hasWordCharAfterProtocolRegex</a> : RegExp<span class=\"signature\"><span class='private' >private</span></span></div><div class='description'><div class='short'>Regex to determine if at least one word char exists after the protocol (i.e. ...</div><div class='long'><p>Regex to determine if at least one word char exists after the protocol (i.e. after the ':')</p>\n<p>Defaults to: <code>/:.*?[A-Za-z]/</code></p></div></div></div><div id='property-invalidProtocolRelMatchRegex' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='Autolinker.MatchValidator'>Autolinker.MatchValidator</span><br/><a href='source/MatchValidator.html#Autolinker-MatchValidator-property-invalidProtocolRelMatchRegex' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Autolinker.MatchValidator-property-invalidProtocolRelMatchRegex' class='name expandable'>invalidProtocolRelMatchRegex</a> : RegExp<span class=\"signature\"><span class='private' >private</span></span></div><div class='description'><div class='short'>The regular expression used to check a potential protocol-relative URL match, coming from the\nAutolinker.matcherRegex. ...</div><div class='long'><p>The regular expression used to check a potential protocol-relative URL match, coming from the\n<a href=\"#!/api/Autolinker-property-matcherRegex\" rel=\"Autolinker-property-matcherRegex\" class=\"docClass\">Autolinker.matcherRegex</a>. A protocol-relative URL is, for example, \"//yahoo.com\"</p>\n\n<p>This regular expression checks to see if there is a word character before the '//' match in order to determine if\nwe should actually autolink a protocol-relative URL. This is needed because there is no negative look-behind in\nJavaScript regular expressions.</p>\n\n<p>For instance, we want to autolink something like \"Go to: //google.com\", but we don't want to autolink something\nlike \"abc//google.com\"</p>\n<p>Defaults to: <code>/^[\\w]\\/\\//</code></p></div></div></div></div></div><div class='members-section'><div class='definedBy'>Defined By</div><h3 class='members-title icon-method'>Methods</h3><div class='subsection'><div id='method-isInvalidProtocolRelativeMatch' class='member first-child not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='Autolinker.MatchValidator'>Autolinker.MatchValidator</span><br/><a href='source/MatchValidator.html#Autolinker-MatchValidator-method-isInvalidProtocolRelativeMatch' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Autolinker.MatchValidator-method-isInvalidProtocolRelativeMatch' class='name expandable'>isInvalidProtocolRelativeMatch</a>( <span class='pre'>protocolRelativeMatch</span> ) : Boolean<span class=\"signature\"><span class='private' >private</span></span></div><div class='description'><div class='short'>Determines if a protocol-relative match is an invalid one. ...</div><div class='long'><p>Determines if a protocol-relative match is an invalid one. This method returns <code>true</code> if there is a <code>protocolRelativeMatch</code>,\nand that match contains a word character before the '//' (i.e. it must contain whitespace or nothing before the '//' in\norder to be considered valid).</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>protocolRelativeMatch</span> : String<div class='sub-desc'><p>The protocol-relative string for a URL match (i.e. '//'), possibly with a preceding\n  character (ex, a space, such as: ' //', or a letter, such as: 'a//'). The match is invalid if there is a word character\n  preceding the '//'.</p>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'>Boolean</span><div class='sub-desc'><p><code>true</code> if it is an invalid protocol-relative match, <code>false</code> otherwise.</p>\n</div></li></ul></div></div></div><div id='method-isValidMatch' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='Autolinker.MatchValidator'>Autolinker.MatchValidator</span><br/><a href='source/MatchValidator.html#Autolinker-MatchValidator-method-isValidMatch' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Autolinker.MatchValidator-method-isValidMatch' class='name expandable'>isValidMatch</a>( <span class='pre'>urlMatch, protocolUrlMatch, protocolRelativeMatch</span> ) : Boolean<span class=\"signature\"></span></div><div class='description'><div class='short'>Determines if a given match found by Autolinker.processTextNode is valid. ...</div><div class='long'><p>Determines if a given match found by <a href=\"#!/api/Autolinker-method-processTextNode\" rel=\"Autolinker-method-processTextNode\" class=\"docClass\">Autolinker.processTextNode</a> is valid. Will return <code>false</code> for:</p>\n\n<p>1) URL matches which do not have at least have one period ('.') in the domain name (effectively skipping over\n   matches like \"abc:def\"). However, URL matches with a protocol will be allowed (ex: 'http://localhost')\n2) URL matches which do not have at least one word character in the domain name (effectively skipping over\n   matches like \"git:1.0\").\n3) A protocol-relative url match (a URL beginning with '//') whose previous character is a word character\n   (effectively skipping over strings like \"abc//google.com\")</p>\n\n<p>Otherwise, returns <code>true</code>.</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>urlMatch</span> : String<div class='sub-desc'><p>The matched URL, if there was one. Will be an empty string if the match is not a URL match.</p>\n</div></li><li><span class='pre'>protocolUrlMatch</span> : String<div class='sub-desc'><p>The match URL string for a protocol match. Ex: 'http://yahoo.com'. This is used to match\n  something like 'http://localhost', where we won't double check that the domain name has at least one '.' in it.</p>\n</div></li><li><span class='pre'>protocolRelativeMatch</span> : String<div class='sub-desc'><p>The protocol-relative string for a URL match (i.e. '//'), possibly with a preceding\n  character (ex, a space, such as: ' //', or a letter, such as: 'a//'). The match is invalid if there is a word character\n  preceding the '//'.</p>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'>Boolean</span><div class='sub-desc'><p><code>true</code> if the match given is valid and should be processed, or <code>false</code> if the match is invalid and/or\n  should just not be processed.</p>\n</div></li></ul></div></div></div><div id='method-urlMatchDoesNotHaveAtLeastOneWordChar' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='Autolinker.MatchValidator'>Autolinker.MatchValidator</span><br/><a href='source/MatchValidator.html#Autolinker-MatchValidator-method-urlMatchDoesNotHaveAtLeastOneWordChar' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Autolinker.MatchValidator-method-urlMatchDoesNotHaveAtLeastOneWordChar' class='name expandable'>urlMatchDoesNotHaveAtLeastOneWordChar</a>( <span class='pre'>urlMatch</span> ) : Boolean<span class=\"signature\"><span class='private' >private</span></span></div><div class='description'><div class='short'>Determines if a URL match does not have at least one word character after the protocol (i.e. ...</div><div class='long'><p>Determines if a URL match does not have at least one word character after the protocol (i.e. in the domain name).</p>\n\n<p>At least one letter character must exist in the domain name after a protocol match. Ex: skip over something\nlike \"git:1.0\"</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>urlMatch</span> : String<div class='sub-desc'><p>The matched URL, if there was one. Will be an empty string if the match is not a URL match.</p>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'>Boolean</span><div class='sub-desc'><p><code>true</code> if the URL match does not have at least one word character in it after the protocol, <code>false</code>\n  otherwise.</p>\n</div></li></ul></div></div></div><div id='method-urlMatchDoesNotHaveProtocolOrDot' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='Autolinker.MatchValidator'>Autolinker.MatchValidator</span><br/><a href='source/MatchValidator.html#Autolinker-MatchValidator-method-urlMatchDoesNotHaveProtocolOrDot' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Autolinker.MatchValidator-method-urlMatchDoesNotHaveProtocolOrDot' class='name expandable'>urlMatchDoesNotHaveProtocolOrDot</a>( <span class='pre'>urlMatch, protocolUrlMatch</span> ) : Boolean<span class=\"signature\"><span class='private' >private</span></span></div><div class='description'><div class='short'>Determines if a URL match does not have either:\n\na) a full protocol (i.e. ...</div><div class='long'><p>Determines if a URL match does not have either:</p>\n\n<p>a) a full protocol (i.e. 'http://'), or\nb) at least one dot ('.') in the domain name (for a non-full-protocol match).</p>\n\n<p>Either situation is considered an invalid URL (ex: 'git:d' does not have either the '://' part, or at least one dot\nin the domain name. If the match was 'git:abc.com', we would consider this valid.)</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>urlMatch</span> : String<div class='sub-desc'><p>The matched URL, if there was one. Will be an empty string if the match is not a URL match.</p>\n</div></li><li><span class='pre'>protocolUrlMatch</span> : String<div class='sub-desc'><p>The match URL string for a protocol match. Ex: 'http://yahoo.com'. This is used to match\n  something like 'http://localhost', where we won't double check that the domain name has at least one '.' in it.</p>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'>Boolean</span><div class='sub-desc'><p><code>true</code> if the URL match does not have a full protocol, or at least one dot ('.') in a non-full-protocol\n  match.</p>\n</div></li></ul></div></div></div></div></div></div></div>","meta":{"private":true}});