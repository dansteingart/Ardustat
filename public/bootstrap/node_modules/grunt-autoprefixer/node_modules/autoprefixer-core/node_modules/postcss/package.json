{
  "name": "postcss",
  "version": "2.2.6",
  "description": "Framework for CSS postprocessors with full source map support",
  "keywords": [
    "css",
    "parser",
    "postproccessor",
    "source map"
  ],
  "author": {
    "name": "Andrey Sitnik",
    "email": "andrey@sitnik.ru"
  },
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "https://github.com/postcss/postcss.git"
  },
  "dependencies": {
    "source-map": "~0.1.40",
    "js-base64": "~2.1.5"
  },
  "devDependencies": {
    "gulp-es6-transpiler": "1.0.0",
    "gulp-json-editor": "2.0.2",
    "jshint-stylish": "1.0.0",
    "gulp-jshint": "1.8.4",
    "gonzales-pe": "3.0.0-10",
    "gulp-mocha": "1.1.0",
    "gulp-util": "3.0.1",
    "fs-extra": "0.12.0",
    "gonzales": "1.0.7",
    "request": "2.44.0",
    "rework": "1.0.1",
    "should": "4.0.4",
    "mocha": "1.21.4",
    "cssom": "0.3.0",
    "gulp": "3.8.8",
    "es6-transpiler": "0.7.16"
  },
  "scripts": {
    "test": "gulp"
  },
  "main": "lib/postcss",
  "readme": "# PostCSS [![Build Status](https://travis-ci.org/postcss/postcss.png)](https://travis-ci.org/postcss/postcss)\n\n<img align=\"right\" width=\"95\" height=\"95\" src=\"http://postcss.github.io/postcss/logo.png\" title=\"Philosopher’s stone, logo of PostCSS\">\n\nPostCSS is a framework for CSS postprocessors,\nto modify CSS with JavaScript with full source map support.\n\nIt takes care of the most common CSS tool tasks:\n\n1. parses CSS;\n2. provides a usable JS API to edit CSS node trees;\n3. dumps the modified node tree into a CSS string;\n4. generates a source map (or modifies an pre-existing source map) containing your changes;\n\nYou can use this framework to write your own:\n\n* CSS minifier or beautifier.\n* CSS polyfills.\n* Grunt plugin to generate sprites, include `data-uri` images\n  or any other work.\n* Text editor plugin to automate CSS routines.\n* Command-line CSS tool.\n\nSponsored by [Evil Martians](http://evilmartians.com/).\n\n## Built with PostCSS\n\n### Tools\n\n* [Autoprefixer] adds vendor prefixes by Can I Use data.\n* [BEM linter] lints CSS for SUIT CSS methodology.\n* [CSS MQPacker] joins same media queries.\n* [css2modernizr] analyzes your CSS and output only used Modernizr’s settings.\n* [cssnext] is a transpiler (CSS4+ to CSS3) that allow you to use tomorrow’s\n  CSS syntax today.\n* [CSSWring] is a CSS minifier with full source map support.\n* [data-separator] splits data-uri into a separate CSS file.\n* [pixrem] is a `rem` unit polyfill.\n* [webpcss] to duplicate images in CSS to WebP for supported browsers.\n* [Pleeease] is a pack of various postprocessors.\n* [Pleeease Filters] converts WebKit filters to SVG filter for other browsers.\n* [RTLCSS] mirrors styles for right-to-left locales.\n* [CSS Byebye] explicitly removes the CSS rules that you don't want.\n\n[Autoprefixer]:      https://github.com/postcss/autoprefixer\n[BEM linter]:        https://github.com/necolas/postcss-bem-linter\n[CSS MQPacker]:      https://github.com/hail2u/node-css-mqpacker\n[css2modernizr]:     https://github.com/vovanbo/css2modernizr\n[cssnext]:           https://github.com/putaindecode/cssnext\n[CSSWring]:          https://github.com/hail2u/node-csswring\n[data-separator]:    https://github.com/Sebastian-Fitzner/grunt-data-separator\n[pixrem]:            https://github.com/robwierzbowski/node-pixrem\n[webpcss]:           https://github.com/lexich/webpcss\n[Pleeease]:          http://pleeease.io/\n[Pleeease Filters]:  https://github.com/iamvdo/pleeease-filters\n[RTLCSS]:            https://github.com/MohammadYounes/rtlcss\n[CSS Byebye]:        https://github.com/AoDev/css-byebye\n\n### Plugins\n\n* [postcss-calc] to reduce `calc()` usage\n  (recommanded with `postcss-custom-properties`).\n* [postcss-color-function] to transform `color()` function.\n* [postcss-color-gray] to transform `gray()` function.\n* [postcss-color-hex-alpha] to transform hexadecimal notations with alpha\n  (`#rrggbbaa` or `#rgba`).\n* [postcss-color-hwb] to transform `hwb()` function.\n* [postcss-color-rebeccapurple] to transform `rebeccapurple` color.\n* [postcss-import] to transform `@import` rules by inlining content.\n* [postcss-custom-media] to add names for Media Queries.\n* [postcss-custom-properties] to transform Custom Properties\n  for cascading variables.\n* [postcss-url] to rebase or inline on `url()`.\n\n[postcss-calc]:                 https://github.com/postcss/postcss-calc\n[postcss-color-function]:       https://github.com/postcss/postcss-color-function\n[postcss-color-gray]:           https://github.com/postcss/postcss-color-gray\n[postcss-color-hex-alpha]:      https://github.com/postcss/postcss-color-hex-alpha\n[postcss-color-hwb]:            https://github.com/postcss/postcss-color-hwb\n[postcss-color-rebeccapurple]:  https://github.com/postcss/postcss-color-rebeccapurple\n[postcss-import]:               https://github.com/postcss/postcss-import\n[postcss-custom-media]:         https://github.com/postcss/postcss-custom-media\n[postcss-custom-properties]:    https://github.com/postcss/postcss-custom-properties\n[postcss-url]:                  https://github.com/postcss/postcss-url\n\n\n## Quick Example\n\nLet’s fix a forgotten `content` property in `::before` and `::after`:\n\n```js\nvar postcss = require('postcss');\n\nvar contenter = postcss(function (css) {\n    css.eachRule(function (rule) {\n        if ( rule.selector.match(/::(before|after)/) ) {\n            // In each ::before/::after rule\n\n            // Did we forget the content property?\n            var good = rule.some(function (i) { return i.prop == 'content'; });\n\n            if ( !good ) {\n                // Add content: \"\" if we forget it\n                rule.prepend({ prop: 'content', value: '\"\"' });\n            }\n\n        }\n    });\n});\n```\n\nAnd the CSS with a forgotten `content` property:\n\n```css\na::before {\n    width: 10px;\n    height: 10px\n}\n```\n\nwill be fixed by our new `contenter`:\n\n```js\nvar fixed = contenter.process(css).css;\n```\n\nto:\n\n```css\na::before {\n    content: \"\";\n    width: 10px;\n    height: 10px\n}\n```\n\n## Features\n\n### Source Map\n\nPostCSS generates a source map of its changes:\n\n```js\nresult = processor.process(css, { map: true, from: 'from.css', to: 'to.css' });\nresult.css // String with processed CSS\nresult.map // Source map\n```\n\nAnd modifies a source map from previous steps (for example, a Sass preprocessor):\n\n```js\nvar sass = compiler.compile(sass);\n\nprocessor.process(sass.css, {\n    map:  { prev: sass.map },\n    from: 'from.sass.css',\n    to:   'to.css'\n});\n```\n\n### Preserves code formatting and indentations\n\nPostCSS will not change any byte of a rule, if you do not modify its node:\n\n```js\npostcss(function (css) { }).process(css).css == css;\n```\n\nAnd when you modify CSS nodes, PostCSS will try to copy the coding style:\n\n```js\ncontenter.process(\"a::before{color:black}\")\n// a::before{content:'';color:black}\n\ncontenter.process(\"a::before {\\n  color: black;\\n  }\")\n// a::before {\n//   content: '';\n//   color: black;\n//   }\n```\n\nWhich allows you to use PostCSS in text editor plugins while preserving\nthe user’s code style.\n\n## Why PostCSS Better Than …\n\n### Preprocessors\n\nPreprocessors (like Sass or Stylus) give us special languages with variables,\nmixins, and statements, which are compiled to CSS. Compass, nib and other mixins\nlibraries use these languages to work with prefixes, sprites and inline images.\n\nBut the Sass and Stylus languages were created to be syntax-sugar for CSS.\nWriting complicated programs using preprocessor languages can be very difficult.\nFor example, it would be impossible to implement [Autoprefixer] on top of Sass.\n\nPostCSS gives you the comfort and power of JS or CoffeeScript while you are working\nwith CSS. Applying the depth and variety of [npm]’s libraries allows you to perform\nquite magical things using PostCSS.\n\nAn important point is that postprocessors are not the enemies of preprocessors.\nPreprocessors and postprocessors can be easily combined, so that you can take\nadvantage of the readability and syntactical sugar offered by Sass and Stylus;\nand PostCSS will preserve their source maps.\n\n[Autoprefixer]: https://github.com/postcss/autoprefixer\n[npm]:          https://npmjs.org/\n\n### Regular Expressions\n\nSome Grunt plugins modify CSS with regular expressions, however a parser\nand its node tree provide a much safer interface to edit CSS. Furthermore,\nregular expressions typically break the source maps generated by preprocessors.\n\n### CSS Parsers\n\nThere are a lot of good CSS parsers, such as [Gonzales], but they only help you\nto read in the CSS. PostCSS provides you with full source map support and a\nhigh level API. Safe iterators, and other features, are unique to PostCSS.\n\n[Gonzales]: https://github.com/css/gonzales\n\n### Rework\n\n[Rework] and PostCSS are very similar, but they have different targets.\n\nRework was created to build a new CSS sublanguage that replaced Stylus (like [Myth]).\nPostCSS was created for CSS tools which work with legacy CSS code (one such\ntool is Autoprefixer).\n\nBecause of this fundamental difference, PostCSS:\n\n* Handles source map better, because it updates the map from the previous step\n  (for example, Sass compilation).\n* Preserves all your spaces and code style, so that it can function in text editor\n  plugins.\n* Has a safer parser, so that it can be used for legacy code. Only PostCSS can\n  parse all of the hacks from [Browserhacks.com](http://browserhacks.com/).\n* Has a high level API to provide an simple interface for your processor to\n  perform typical tasks.\n\n[Myth]:   http://www.myth.io/\n[Rework]: https://github.com/visionmedia/rework\n\n## Usage\n\n### Grunt\n\nGrunt plugin [grunt-postcss] allows you to pipe your CSS files through\nan array of PostCSS processors.\n\n```js\ngrunt.initConfig({\n    postcss: {\n        options: {\n            map: true,\n            processors: [\n                require('autoprefixer-core').postcss,\n                require('csswring').postcss\n            ]\n        },\n        dist: {\n            src: 'css/*.css'\n        }\n    }\n});\n\ngrunt.loadNpmTasks('grunt-postcss');\n```\n\n[grunt-postcss]: https://github.com/nDmitry/grunt-postcss\n\n### Gulp\n\nThere is a Gulp plugin for PostCSS called [gulp-postcss] that allows you\nto pipe your CSS files through an array of PostCSS processors.\n\nSupport for external source maps is provided by [gulp-sourcemaps].\n\n```js\nvar postcss    = require('gulp-postcss');\nvar sourcemaps = require('gulp-sourcemaps');\n\ngulp.task('css', function () {\n    var processors = [\n        require('autoprefixer-core'),\n        require('csswring')\n     ];\n     return gulp.src('./src/style.css')\n        .pipe(sourcemaps.init())\n        .pipe(postcss(processors))\n        .pipe(sourcemaps.write('.'))\n        .pipe(gulp.dest('./dest'));\n});\n```\n\n[gulp-postcss]:    https://github.com/w0rm/gulp-postcss\n[gulp-sourcemaps]: https://github.com/floridoo/gulp-sourcemaps\n\n### Webpack\n\nIn [webpack] you can use [postcss-loader] to process CSS files through\nan array of PostCSS processors.\n\n```js\nmodule.exports = {\n    module: {\n        loaders: [\n            {\n                test:   /\\.css$/,\n                loader: \"style-loader!css-loader!postcss-loader\"\n            }\n        ]\n    },\n    postcss: [require('autoprefixer-core'), require('csswring')]\n}\n```\n\n[postcss-loader]: https://github.com/postcss/postcss-loader\n[webpack]:        http://webpack.github.io/\n\n## Write Own Processor\n\nYou can parse CSS with the `postcss.parse()` method, which returns a CSS AST:\n\n```js\nvar postcss = require('postcss');\n\nvar css = postcss.parse('a { color: black }');\n```\n\nYou can easily make changes to this AST. Use `css.list` to get children.\nProperties `rule.selector`, `decl.prop`, `decl.value`, `atrule.name`\nand `atrule.params` contain data.\n\nTry to avoid using underscore-prefixed properties (such as `_selector`, `_params` and `_value`),\nas they are used for comment-preserving magic\n(See [Raw Properties](#raw-properties) below). Use the getters and setters instead\n(for example, `selector`, `selectors`, `params` and `value`).\n\n```js\ncss.list[0].value = 'white';\n```\n\nAfter changes have been made you can get the new CSS and a source map reflecting\nthe modifications:\n\n```js\nvar result = css.toResult(options);\n\nresult.css //=> 'a { color: white }'\nresult.map //=> '{\"version\":3, … }'\n```\n\nThe methods `postcss.parse()` and `CSS#toResult()` are part of a low level API, and -\nin most cases - it will be better to create processors with a simpler API and chaining.\n\n### Processor\n\nThe function `postcss(fn)` creates a processor from your function:\n\n```js\nvar postcss = require('postcss');\n\nvar processor = postcss(function (css, opts) {\n    // Code to modify CSS\n});\n```\n\nIf you want to combine multiple processors (and parse the CSS only once),\nyou can add several functions using the `use(fn)` method:\n\n```js\nvar all = postcss().\n          use(prefixer).\n          use(minifing);\n```\n\nYou can also add processor objects with the `postcss` function:\n\n```js\npostcss().use( autoprefixer.postcss ); // via function\npostcss().use( autoprefixer );         // via object\n```\n\nA processor function can change the current CSS node tree:\n\n```js\npostcss(function (css) {\n    css.append( /* new rule */ )\n});\n```\n\nor create a completely new CSS root node and return it instead:\n\n```js\npostcss(function (css) {\n    var newCSS = postcss.root()\n    // Add rules and declarations\n    return newCSS;\n});\n```\n\nThis generated processor transforms some CSS using the `process(css, opts)` method:\n\n```js\nvar doubler = postcss(function (css) {\n    // Clone each declaration\n    css.eachDecl(function (decl) {\n        decl.parent.prepend( decl.clone() );\n    });\n});\n\nvar css    = \"a { color: black; }\";\nvar result = doubler.process(css);\n\nresult.css //=> \"a { color: black; color: black; }\"\n```\n\nYou can change the original CSS filename via the `from` option, which\ncan make syntax error more helpful:\n\n```js\nvar wrong = \"a {\";\nprocessor.process(wrong, { from: 'main.css' });\n//=> Can't parse CSS: Unclosed block at line 1:1 in main.css\n```\n\nOptions from `process(css, opts)` will be sent to processors\nas the second argument.\n\nYou can also use the result from a previous postprocessor, or\nan already-parsed `Root`, as an argument to the next one:\n\n```js\nresult = processor1.process(css)\nprocessor2.process(result)\n```\n\n### Multiple Inputs\n\nThe function `postcss()` generates a processor for only one input.\nIf you need to process several inputs (for example, when concatenating files)\nyou can use `postcss.parse()`.\n\nLet’s join two CSS strings with full source map support in only 5 lines of code:\n\n```js\nvar file1 = postcss.parse(css1, { from: 'a.css' });\nvar file2 = postcss.parse(css2, { from: 'b.css' });\n\nfile1.append( file2 );\n\nvar result = file1.toResult({ to: 'app.css', map: true });\n```\n\n### Source Map\n\nBy using [source maps], a browser’s development tools can indicate the\noriginal position of your styles before the css file was transformed.\nFor example, an inspector will show the position in a Sass file, even if\nthe file has been compiled to CSS, concatenated, and minified.\n\nTo ensure a correct source map is generated, every CSS processing step should update\nthe map generated by the previous step. For example, a Sass compiler will generate\nthe first map, a concatenation tool should update the Sass step’s map, and a minifier\nshould update the map generated by the concatenation tool.\n\nThere are two ways to store a source map:\n\n* You can place it in a separate file which contains a special annotation comment\n  pointing to another file:\n\n  ```css\n a { }\n /*# sourceMappingURL=main.out.css.map */\n  ```\n* Or you can inline a base64-encoded source map within a CSS comment:\n\n  ```css\n a { }\n /*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFpbi5taW4uY3NzIiwic291cmNlcyI6WyJtYWluLmNzcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxJQUFLIn0= */\n  ```\n\nPostCSS has great source map support. To ensure that you generate the correct\nsource map, you must indicate the input and output CSS files\npaths (using the options `from` and `to` respectively).\n\nTo generate a new source map with the default options, provide `map: true` in the\noptions passed to `processor.process(css, opts)`.\n\n```js\nvar result = processor.process(css, {\n    from: 'main.css',\n    to:   'main.out.css'\n    map:  true,\n});\n\nresult.map //=> '{\"version\":3,\"file\":\"main.out.css\",\"sources\":[\"main.css\"],\"names\":[],\"mappings\":\"AAAA,KAAI\"}'\n\nfs.writeFileSync('main.out.css',     result.css);\nfs.writeFileSync('main.out.css.map', result.map);\n```\n\nOr set `from` in `postcss.parse(css, opts)` and `to` in `root.toResult(opts)`:\n\n```js\nvar root = postcss.parse(css, { from: 'main.css' });\nroot.last.removeSelf(); // Example transformation\n\nvar result = root.toResult({ to: 'main.out.css' });\nfs.writeFileSync('main.out.css',     result.css);\nfs.writeFileSync('main.out.css.map', result.map);\n```\n\nIf PostCSS is handling CSS and finds source maps from previous transformations, it will\nautomatically update the CSS with the same options.\n\n```js\n// main.sass.css has an annotation comment with a link to main.sass.css.map\nvar result = minifier.process(css, { from: 'main.sass.css', to: 'main.min.css' });\nresult.map //=> Source map from main.sass to main.min.css\n```\n\nIf you want more control over source map generation, you can define the `map` option\nas an object with the following parameters:\n\n* `inline` (boolean): indicates the source map should be inserted into the CSS string as\n  a comment. By default, PostCSS will inline new source maps only if the source map from\n  a previous step inserted an inline source map.\n\n  If you inline a source map, `result.map` will be empty, as the source map will be\n  contained within the text of `result.css`.\n\n  As a shortcut, `map { inline: true }` is equivalent to `map: 'inline'`.\n\n* `prev` (string, object, or boolean): map content from a previous processing step\n  (for example, Sass compilation). PostCSS will try to read the previous source map\n  automatically from the comment within origin CSS, but you can also set manually.\n  If desired, you can omit the previous map with `prev: false`.\n\n  This is a source map option which can be passed to `postcss.parse(css, opts)`.\n  Other options can be passed to the `toResult(opts)` or `process(css, opts)` methods.\n\n* `sourcesContent` (boolean): indicates that we should set the origin content\n  (for example, Sass source) of the source map. By default, PostCSS will add\n  content only if previous map contains it.\n\n* `annotation` (boolean or string): indicates if we should add annotation comments\n  to the CSS. By default, PostCSS will always add a comment with a path to the source\n  map. But if the previous CSS does not have an annotation comment, PostCSS will\n  omit it too.\n\n  By default, PostCSS presumes that you want to save the source map as\n  `opts.to + '.map'` and will use this path in the annotation comment. But you can\n  set another path by providing a string value as the `annotation` option.\n\n  If you set `inline: true`, annotation cannot be disabled.\n\n[source maps]: http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/\n\n### Safe Mode\n\nIf you provide a `safe: true` option to the `process` or `parse` methods,\nPostCSS will try to correct any syntax error that it finds in the CSS.\nFor example, it will parse `a {` as `a {}`.\n\n```js\npostcss.parse('a {');                 // will throw \"Unclosed block\"\npostcss.parse('a {', { safe: true }); // will return CSS root for a {}\n```\n\nThis is useful for legacy code filled with plenty of hacks. Another use case\nis interactive tools with live input, for example,\nthe [Autoprefixer demo](http://jsfiddle.net/simevidas/udyTs/show/light/).\n\n### Helpers\n\n#### Vendor\n\nPostCSS contains height optimized code to split vendor prefix:\n\n```js\nvar vendor = require('postcss/lib/vendor');\n\nvendor.prefix('-moz-tab-size')     //=> '-moz-'\nvendor.unprefixed('-moz-tab-size') //=> 'tab-size'\n```\n\n#### List\n\nTo safely split comma- or space-separated values (such as those in `background-image`\nor `transform`) with brackets and quotes support, you can use the `list` helper:\n\n```js\nvar list = require('postcss/lib/list');\n\nlist.space(image.value)     //=> ['linear-gradient(white, black)', 'blue']\nlist.comma(transform.value) //=> ['color 200ms', 'background 200ms']\n```\n\n### Nodes\n\nProcessor functions receive a `Root` node which contains the CSS node tree.\n\n```js\nvar processor = postcss(function (cssRoot) {\n});\n```\n\nThere are 4 types of child nodes: `Comment`, `AtRule`, `Rule` and `Declaration`.\nAll nodes possess `toString()` and `clone()` methods.\n\nYou can parse CSS and get a `Root` node by calling the `postcss.parse(css, opts)` method:\n\n```js\nvar cssRoot = postcss.parse('a { }');\n```\n\nMany of the methods on a node will return the current node, which enables\nyou to build method chains:\n\n```js\nroot.append( rule1 ).append( rule2 ).toString();\n```\n\n### Node Source\n\nEvery node stores its origin file (if you provide the `from` option to the `process`\nor `parse` methods) and position:\n\n```js\nvar root = postcss.parse(css, { from: 'main.css' });\nvar rule = root.rules[0];\n\nrule.source.file  //=> 'main.css'\nrule.source.start //=> { line: 5,  position: 1 }\nrule.source.end   //=> { line: 10, position: 5 }\n```\n\n### Whitespace\n\nAll nodes (excluding the `Root`) have a `before` property which contains\nthe indentation and any previous whitespace.\n\nNodes with children (`Root`, `AtRule` and `Rule`) also contain an `after`\nproperty which indicates the spaces after the last child and before a `}`\ncharacter or the end of the file.\n\nEvery `Declaration` has a `between` property with colon, spaces and comments\nbetween the property name and value. `Rule` stores the spaces and comments between\nthe selector and `{` in the `between` property. `AtRule` uses `between` to\nindicate the spaces and comments before either a `{` or `;`, if the at-rule\nis bodiless.\n\n```js\nvar root = postcss.parse(\"a {\\n  color: black;\\n}\\n\");\n\nroot.rules[0].between          //=> \" \" between selector and {\nroot.rules[0].decls[0].before  //=> \"\\n  \" before color: black\nroot.rules[0].decls[0].between //=> \": \" between property name and value\nroot.rules[0].after            //=> \"\\n\" before }\nroot.after                     //=> \"\\n\" from end of file\n```\n\nThe simplest way to minify CSS is to set `before`, `between` and `after`\nproperties to an empty string:\n\n```js\nvar minifier = postcss(function (css) {\n    css.eachDecl(function (decl) {\n        decl.before  = '';\n        decl.between = ':';\n    });\n    css.eachRule(function (rule) {\n        rule.before  = '';\n        rule.between = '';\n        rule.after   = '';\n    });\n    css.eachAtRule(function (atRule) {\n        atRule.before  = '';\n        atRule.between = '';\n        atRule.after   = '';\n    });\n    css.eachComment(function (comment) {\n        comment.removeSelf();\n    });\n});\n\nvar css = \"a {\\n  color:black\\n}\\n\";\nminifier.process(css).css //=> \"a{color:black}\"\n```\n\nNote that nodes may have not `before` or `between` properties:\n\n* If node was created by hand via `postcss.rule()`.\n* `node.clone()` will clean all style properties to use the style for a new CSS root.\n\n### Raw Properties\n\nSome CSS values (selectors, comment text, at-rule params and declaration values)\ncan contain comments. PostCSS will clean them to remove trailing spaces:\n\n```js\nvar root = postcss.parse(\"a /**/ b {}\");\nvar rule  = root.rules[0];\n\nrule.selector      //=> 'a  b' trimmed and cleaned from comments\nrule._selector.raw //=> 'a /**/ b' original raw value\n```\n\nBut PostCSS preservers the raw content in order to stringify it back to CSS,\nin case you don’t change the original value. In general, PostCSS tries to preserve\nthe original CSS byte-to-byte whenever possible:\n\n```js\nrule.toString() //=> 'a /**/ b {}' with comment\n\nrule.selector = '.link b';\nrule.toString() //=> '.link b {}' you change value and origin comment was gone\n```\n\n### Containers\n\n`Root`, `AtRule` and `Rule` nodes can contain children in `rules` or `decls`\nproperties.\n\nThere are some common methods to perform work on children:\n\n* `append(newChild)` adds a child at the end of the children list.\n* `prepend(newChild)` adds a child at the beginning of the children list.\n* `insertBefore(existsChild, newChild)` inserts a new child before a\n   pre-existing child.\n* `insertAfter(existsChild, newChild)` inserts a new child after some\n   pre-existing child.\n* `remove(existsChild)` removes a child.\n* `index(existsChild)` returns a child’s index.\n* `some(fn)` returns true if `fn` returns true for any child.\n* `every(fn)` returns true if `fn` returns true for all children.\n\nMethods `append`, `prepend`, `insertBefore` and `insertAfter` will also accept\narrays and `Root` nodes as an argument.\n\nMethods `insertBefore`, `insertAfter` and `remove` will accept child nodes\nor indexes as the `existsChild` argument. Note that providing a child index will\nresult in the method completing much faster.\n\nThere are two shortcuts to provide the first and last child of a node:\n\n```js\nrule.first //=> First declaration in rule\nrule.last  //=> Last declaration in rule\n```\n\n### Children\n\n`Comment`, `AtRule`, `Rule` and `Declaration` nodes should be wrapped\nin other nodes.\n\nAll children contain a `parent` property which indicates the parent node:\n\n```js\nrule.decls[0].parent == rule;\n```\n\nAll children have a `removeSelf()` method:\n\n```js\nrule.decls[0].removeSelf();\n```\n\nBut invoking the `remove(index)` method on the parent is much faster:\n\n```js\nrule.each(function (decl, i) {\n    rule.remove(i);\n});\n```\n\n### Iterators\n\nAll parent nodes have an `each` method which allows you to iterate over\nits child nodes:\n\n```js\nroot = postcss.parse('a { color: black; display: none }');\n\nroot.each(function (rule, i) {\n    if ( rule.type == 'rule' ) {\n        console.log(rule.selector, i); // Will log \"a 0\"\n    }\n});\n\nroot.rules[0].each(function (decl, i) {\n    if ( rule.type != 'comment' ) {\n        console.log(decl.prop, i); // Will log \"color 0\" and \"display 1\"\n    }\n});\n```\n\nUnlike `for {}`-cycle construct or `Array#forEach()` this iterator is safe.\nSo you can mutate the children during iteration and PostCSS will fix the current index:\n\n```js\nrule.rules.forEach(function (decl, i) {\n    rule.prepend( decl.clone() );\n    // Will infinitely cycle as prepending the current declaration will\n    // cause the second and successive indexes to interact with the\n    // current declaration endlessly\n});\n\nrule.each(function (decl, i) {\n    rule.prepend( decl.clone() );\n    // Will work correctly (each declaration will be cloned only once),\n    // because the iterator index will be recalculated only after the prepend\n});\n```\n\nBecause CSS has a nested structure, PostCSS also features a recursive iterator\n`eachInside`:\n\n```js\nroot.eachInside(function (node, i) {\n    console.log(node.type + ' inside ' + node.parent.type);\n});\n```\n\nThere are also shortcuts so that you can recursively iterate over nodes of\na specific type:\n\n```js\nroot.eachDecl(function (decl, i) {\n    // Each declaration inside root\n});\n\nroot.eachRule(function (rule, i) {\n    // Each rule inside root and any nested at-rules\n});\n\nroot.eachAtRule(function (atRule, i) {\n    // Each at-rule inside root and any nested at-rules\n});\n\nroot.eachComment(function (comment, i) {\n    // Each comment inside root\n})\n```\n\nYou can break out from the iteration by returning `false`.\n\n### Root Node\n\n`Root` node contains the entire CSS tree. Its children can only be `Comment`,\n`AtRule`, or `Rule` nodes in the `rules` property.\n\nYou can create a new root using the shortcut:\n\n```js\nvar root = postcss.root();\n```\n\nMethod `toString()` stringifies the entire node tree and returns a CSS string:\n\n```js\nroot = postcss.parse(css);\nroot.toString() == css;\n```\n\nIf PostCSS found previous source map, it will save all the relevant information\nwithin `Root#prevMap`:\n\n```\nroot = postcss.parse(css);\nif (root.prevMap && root.prevMap.inline) {\n    console.log('Inlined map: ' + root.prevMap.annotation)\n}\n```\n\n### Comment Node\n\n```css\n/* Block comment */\n```\n\nPostCSS creates `Comment` nodes only for comments found between rules or declarations.\nComments found within selectors, at-rules params, or declaration values will be stored\nin the Raw property.\n\n`Comment` has only one property: `text` which contains the trimmed text inside the comment.\n\n```js\ncomment.text //=> \"Block comment\"\n```\n\nYou can create a new comment using a shortcut:\n\n```js\nvar comment = postcss.comment({ text: 'New comment' });\n```\n\n### AtRule Node\n\n```css\n@charset 'utf-8';\n\n@font-face {\n    font-family: 'Cool'\n}\n\n@media print {\n    img { display: none }\n}\n```\n\n`AtRule` has two own properties: `name` and `params`.\n\nAs illustrated above, some at-rules do not contain any children\n(for example, `@charset` or `@import`), some at-rules can only contain\ndeclarations (for example, `@font-face` or `@page`), but most of them\ncan contain rules and nested at-rules (for example, `@media`, `@keyframes`\nand others).\n\nThe parser selects `AtRule` content type by its name. If you create an `AtRule`\nnode manually, it will infer its content type by the first child added via\nthe `append` or other methods:\n\n```js\nvar atRule = postcss.atRule({ name: '-x-animations' });\natRule.rules        //=> undefined\natRule.decls        //=> undefined\n\natRule.append( postcss.rule({ selector: 'from' }) );\natRule.rules.length //=> 1\natRule.decls        //=> undefined\n```\n\nYou can create a new at-rule using a shortcut:\n\n```js\nvar atRule = postcss.atRule({ name: 'charset', params: 'utf-8' });\n```\n\n### Rule Node\n\n```css\na {\n    color: black;\n}\n```\n\n`Rule` nodes have a `selector` property and contain their `Declaration`\nand `Comment` children within the `decls` property.\n\nThey also possess a `selectors` shortcut, which returns an array:\n\n```js\nrule.selector  //=> \"a, b\"\nrule.selectors //=> ['a', 'b']\n```\n\nYou can avoid using the `Declaration` constructor for `append` and other insert methods, by:\n\n```js\nrule.append({ prop: 'color', value: 'black' });\n```\n\nThe property `semicolon` indicates if the last declaration within the rule has a semicolon or not:\n\n```js\nvar root = postcss.parse('a { color: black }');\nroot.rules[0].semicolon //=> false\n\nvar root = postcss.parse('a { color: black; }');\nroot.rules[0].semicolon //=> true\n```\n\nYou can create a new rule using a shortcut:\n\n```js\nvar rule = postcss.rule({ selector: 'a' });\n```\n\n### Declaration Node\n\n```css\ncolor: black\n```\n\n`Declaration` nodes have `prop`, `value` and `important` properties.\n\nYou can create a new declaration using a shortcut:\n\n```js\nvar decl = postcss.decl({ prop: 'color', value: 'black' });\n```\n\nOr you can use the short form available via a rule’s `append()` and other add methods:\n\n```js\nrule.append({ prop: 'color', value: 'black' });\n```\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/postcss/postcss/issues"
  },
  "_id": "postcss@2.2.6",
  "dist": {
    "shasum": "c04344e2449e4586b955fbe4a74f77080d84571f"
  },
  "_from": "postcss@~2.2.5",
  "_resolved": "https://registry.npmjs.org/postcss/-/postcss-2.2.6.tgz"
}
