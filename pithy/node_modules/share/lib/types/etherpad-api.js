// Generated by CoffeeScript 1.6.2
var AttributePool, Changeset, attribsToTokens, etherpad;

if (typeof WEB !== "undefined" && WEB !== null) {
  if ((window.ShareJS != null) && (window.ShareJS.Changeset != null)) {
    Changeset = window.ShareJS.Changeset;
    AttributePool = window.ShareJS.AttributePool;
  }
} else {
  etherpad = require('./etherpad');
  AttributePool = require('./../lib-etherpad/AttributePool.js');
  Changeset = require('./../lib-etherpad/Changeset.js');
}

attribsToTokens = function(attribs, text, pool) {
  var iter, op, str, stringIter, tokens;

  iter = Changeset.opIterator(attribs);
  tokens = [];
  stringIter = Changeset.stringIterator(text);
  while (iter.hasNext()) {
    op = iter.next();
    str = [];
    op.attribs.replace(/\*([0-9a-z]+)/g, function(_, a) {
      var pair;

      pair = pool.getAttrib(Changeset.parseNum(a));
      return str.push(pair);
    });
    tokens.push({
      type: str,
      value: stringIter.take(Math.min(op.chars, stringIter.remaining()))
    });
  }
  return tokens;
};

etherpad.api = {
  provides: {
    text: true
  },
  getLength: function() {
    return this.snapshot.text.length;
  },
  getText: function() {
    return this.snapshot.text;
  },
  mergeTokens: function(iterTokens, modeTokens) {
    var attr, docCS, i, parserAttributes, parserCS, parserPool, res, resultCS, text, token, tokens, _i, _j, _k, _len, _len1, _len2, _ref;

    if (this.snapshot.pool.getAttrib == null) {
      this.snapshot = etherpad.tryDeserializeSnapshot(this.snapshot);
    }
    text = iterTokens.text;
    parserPool = new AttributePool();
    parserAttributes = Changeset.builder(text.length);
    for (_i = 0, _len = modeTokens.length; _i < _len; _i++) {
      attr = modeTokens[_i];
      parserAttributes.keep(attr.value.length, 0, [[attr.type, true]], parserPool);
    }
    parserCS = parserAttributes.toString();
    docCS = Changeset.pack(text.length, text.length, iterTokens.attribs.replace(/\+/g, "="), "");
    docCS = Changeset.moveOpsToNewPool(docCS, this.snapshot.pool, parserPool);
    resultCS = Changeset.unpack(Changeset.compose(parserCS, docCS, parserPool));
    tokens = attribsToTokens(resultCS.ops, text, parserPool);
    for (_j = 0, _len1 = tokens.length; _j < _len1; _j++) {
      token = tokens[_j];
      res = "";
      _ref = token.type;
      for (i = _k = 0, _len2 = _ref.length; _k < _len2; i = ++_k) {
        attr = _ref[i];
        if (i > 0) {
          res += " ace_" + attr[0];
        } else {
          res += attr[0];
        }
      }
      token.type = res;
    }
    return tokens;
  },
  cloneIterator: function(iter) {
    return {
      textPos: iter.textPos,
      attribPos: iter.attribPos,
      attribConsumed: iter.attribConsumed
    };
  },
  consumeIterator: function(iter, length) {
    var assem, op, opIter, text;

    if (length === 0) {
      return {
        "attribs": "",
        "text": ""
      };
    }
    text = this.snapshot.text.substring(iter.textPos, iter.textPos + length);
    iter.textPos += length;
    opIter = Changeset.opIterator(this.snapshot.attribs, iter.attribPos);
    Changeset.assert(opIter.hasNext(), "iterator out of range");
    op = opIter.next();
    Changeset.assert(op.chars > iter.attribConsumed, "consumed <= available");
    op.chars -= iter.attribConsumed;
    assem = Changeset.smartOpAssembler();
    while (op.chars <= length) {
      assem.append(op);
      iter.attribConsumed = 0;
      length -= op.chars;
      iter.attribPos = opIter.lastIndex();
      if (length === 0) {
        break;
      }
      Changeset.assert(opIter.hasNext(), "iterator out of range");
      op = opIter.next();
    }
    op.chars = length;
    assem.append(op);
    iter.attribConsumed += length;
    return {
      "attribs": assem.toString(),
      "text": text
    };
  },
  createIterator: function(startOffset) {
    var iter;

    if (startOffset == null) {
      startOffset = 0;
    }
    iter = {
      attribPos: 0,
      textPos: 0,
      attribConsumed: 0
    };
    if (startOffset > 0) {
      this.consumeIterator(iter, startOffset);
    }
    return iter;
  },
  setAttributes: function(startOffset, length, attribs, callback) {
    var op;

    if (this.snapshot.pool.getAttrib == null) {
      this.snapshot = etherpad.tryDeserializeSnapshot(this.snapshot);
    }
    op = {
      pool: new AttributePool()
    };
    op.changeset = Changeset.builder(this.getLength()).keep(startOffset).keep(length, 0, attribs, op.pool).toString();
    this.emit('refresh', startOffset, length);
    return this.submitOp(op, callback);
  },
  getAttributes: function(startOffset, length) {
    var iter, op;

    if (this.snapshot.pool.getAttrib == null) {
      this.snapshot = etherpad.tryDeserializeSnapshot(this.snapshot);
    }
    iter = this.createIterator(startOffset);
    op = this.consumeIterator(iter, length);
    return attribsToTokens(op.attribs, op.text, this.snapshot.pool);
  },
  insert: function(pos, text, callback) {
    var attribs, result;

    result = {};
    result.pool = new AttributePool();
    attribs = [
      {
        type: ""
      }
    ];
    if (pos > 0) {
      attribs = this.getAttributes(pos - 1, 1);
    }
    result.changeset = Changeset.builder(this.snapshot.text.length).keep(pos).insert(text, attribs[0].type, result.pool).toString();
    this.submitOp(result, callback);
    return result;
  },
  del: function(pos, length, callback) {
    var result;

    result = {};
    result.pool = new AttributePool();
    result.changeset = Changeset.builder(this.snapshot.text.length).keep(pos).remove(length).toString();
    this.submitOp(result, callback);
    return result;
  },
  _register: function() {
    return this.on('remoteop', function(op) {
      var iter, o, offset, origSnapOffset, refreshFirstOffset, refreshLastOffset, strIter, unpacked, _results;

      unpacked = Changeset.unpack(op.changeset);
      iter = Changeset.opIterator(unpacked.ops);
      strIter = Changeset.stringIterator(unpacked.charBank);
      offset = 0;
      origSnapOffset = 0;
      refreshFirstOffset = 10000000;
      refreshLastOffset = -1;
      _results = [];
      while (iter.hasNext()) {
        o = iter.next();
        switch (o.opcode) {
          case '+':
            this.emit('insert', offset, strIter.take(o.chars));
            offset = offset + o.chars;
            break;
          case '-':
            this.emit('delete', offset, this.snapshot.text.substring(origSnapOffset, origSnapOffset + o.chars));
            origSnapOffset += o.chars;
            break;
          case '=':
            if (o.attribs.length > 0) {
              refreshFirstOffset = Math.min(offset, refreshFirstOffset);
              refreshLastOffset = Math.max(offset + o.chars, refreshLastOffset);
            }
            offset = offset + o.chars;
            origSnapOffset += o.chars;
        }
        if (refreshLastOffset > 0) {
          _results.push(this.emit('refresh', refreshFirstOffset, refreshLastOffset - refreshFirstOffset));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    });
  }
};

exports.etherpad = etherpad;
