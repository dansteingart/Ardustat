// Generated by CoffeeScript 1.6.2
/*
This behaves like a WebSocket in every way, except if it fails to connect,
or it gets disconnected, it will repeatedly poll until it succesfully connects
again.

It is API compatible, so when you have:
ws = new WebSocket('ws://....');
you can replace with:
ws = new ReconnectingWebSocket('ws://....');

The event stream will typically look like:
onopen
onmessage
onmessage
onclose // lost connection
onopen  // sometime later...
onmessage
onmessage
etc...

It is API compatible with the standard WebSocket API.

Inspired from: https://github.com/joewalnes/reconnecting-websocket/
Contributors:
- Joe Walnes
- Didier Colens
- Wout Mertens
*/

var ReconnectingWebSocket;

ReconnectingWebSocket = (function() {
  function ReconnectingWebSocket(url, protocols, Socket) {
    var connect, timedOut,
      _this = this;

    if ((protocols != null) && typeof protocols === 'function') {
      Socket = protocols;
      protocols = void 0;
    } else if (typeof Socket !== 'function') {
      Socket = WebSocket;
    }
    this.debug = this.debugAll;
    this.reconnectInterval = 1000;
    this.timeoutInterval = 2000;
    this.forcedClose = false;
    this.url = url;
    this.protocols = protocols;
    this.readyState = Socket.CONNECTING;
    this.URL = url;
    timedOut = false;
    connect = function(reconnectAttempt) {
      var timeout;

      _this.ws = new Socket(_this.url);
      if (_this.debug) {
        console.debug("ReconnectingWebSocket", "attempt-connect", _this.url);
      }
      timeout = setTimeout(function() {
        if (_this.debug) {
          console.debug("ReconnectingWebSocket", "connection-timeout", _this.url);
        }
        timedOut = true;
        _this.ws.close();
        return timedOut = false;
      }, _this.timeoutInterval);
      _this.ws.onopen = function(event) {
        clearTimeout(timeout);
        if (_this.debug) {
          console.debug("ReconnectingWebSocket", "onopen", _this.url);
        }
        _this.readyState = Socket.OPEN;
        reconnectAttempt = false;
        return _this.onopen(event);
      };
      _this.ws.onclose = function(event) {
        clearTimeout(timeout);
        _this.ws = null;
        if (_this.forcedClose) {
          _this.readyState = Socket.CLOSED;
          return _this.onclose(event);
        } else {
          _this.readyState = Socket.CONNECTING;
          _this.onconnecting(event);
          if (!reconnectAttempt && !timedOut) {
            if (_this.debug) {
              console.debug("ReconnectingWebSocket", "onclose", _this.url);
            }
            _this.onclose(event);
          }
          return setTimeout((function() {
            return connect(true);
          }), _this.reconnectInterval);
        }
      };
      _this.ws.onmessage = function(event) {
        if (_this.debug) {
          console.debug("ReconnectingWebSocket", "onmessage", _this.url, event.data);
        }
        return _this.onmessage(event);
      };
      return _this.ws.onerror = function(event) {
        if (_this.debug) {
          console.debug("ReconnectingWebSocket", "onerror", _this.url, event);
        }
        return _this.onerror(event);
      };
    };
    connect(this.url);
  }

  ReconnectingWebSocket.prototype.onopen = function(event) {};

  ReconnectingWebSocket.prototype.onclose = function(event) {};

  ReconnectingWebSocket.prototype.onconnecting = function(event) {};

  ReconnectingWebSocket.prototype.onmessage = function(event) {};

  ReconnectingWebSocket.prototype.onerror = function(event) {};

  ReconnectingWebSocket.prototype.send = function(data) {
    if (this.ws) {
      if (this.debug) {
        console.debug("ReconnectingWebSocket", "send", this.url, data);
      }
      return this.ws.send(data);
    } else {
      throw "INVALID_STATE_ERR : Pausing to reconnect websocket";
    }
  };

  ReconnectingWebSocket.prototype.close = function() {
    if (this.ws) {
      this.forcedClose = true;
      return this.ws.close();
    }
  };

  /*
  Setting this to true is the equivalent of setting all instances of ReconnectingWebSocket.debug to true.
  */


  ReconnectingWebSocket.prototype.debugAll = false;

  /*
  Additional public API method to refresh the connection if still open (close, re-open).
  For example, if the app suspects bad data / missed heart beats, it can try to refresh.
  */


  ReconnectingWebSocket.prototype.refresh = function() {
    if (this.ws) {
      return this.ws.close();
    }
  };

  return ReconnectingWebSocket;

})();
