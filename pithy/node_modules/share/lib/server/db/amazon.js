// Generated by CoffeeScript 1.6.2
var AmazonDb, BinaryCompressor, BlobHandler, DynamoQueue, S3Queue, TextCompressor, amazon, async, awssum, defaultOptions, retry, util, zlib,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

util = require('util');

async = require('async');

retry = require('retry');

zlib = require('zlib');

awssum = require('awssum');

amazon = awssum.load('amazon/amazon');

defaultOptions = {
  amazon_s3_region: amazon.US_EAST_1,
  amazon_dynamo_region: amazon.US_EAST_1,
  timing: false,
  compress: true,
  s3_rw_concurrency: 1,
  s3_ro_concurrency: 1,
  snapshots_ro_concurrency: 1,
  snapshots_rw_concurrency: 1,
  operations_ro_concurrency: 1,
  operations_rw_concurrency: 1
};

DynamoQueue = (function() {
  function DynamoQueue(name, concurrency, timing) {
    this.name = name;
    this.timing = timing;
    this.push = __bind(this.push, this);
    this.queue = async.queue(function(task, callback) {
      return task(callback);
    }, concurrency);
  }

  DynamoQueue.prototype.push = function(fn, description, callback) {
    var operation,
      _this = this;

    operation = this._retryableOperation();
    return operation.attempt(function(currentAttempt) {
      var start;

      start = new Date().getTime();
      return _this.queue.push(fn, function(error, results) {
        var attempt, capacity, elapsed, retried;

        elapsed = new Date().getTime() - start;
        attempt = operation.attempts();
        capacity = results != null ? results.Body.ConsumedCapacityUnits : -1;
        if (_this._shouldRetry(error)) {
          retried = operation.retry(error);
        } else {
          retried = false;
        }
        if (retried) {
          return console.error('Dyname[#' + attempt + ',' + elapsed + 'ms,' + capacity + '] ' + _this.name + ': Retrying ' + description + ' due to ' + util.inspect(error));
        } else {
          if (_this.timing) {
            console.log('Dynamo[#' + attempt + ',' + elapsed + 'ms,' + capacity + '] ' + _this.name + ': ' + description);
          }
          return callback(error, results);
        }
      });
    });
  };

  DynamoQueue.prototype._shouldRetry = function(error) {
    if (error && (error.Body != null) && (error.Body.message != null) && error.Body.message.match('The conditional request failed')) {
      return false;
    } else {
      return true;
    }
  };

  DynamoQueue.prototype._retryableOperation = function() {
    return retry.operation({
      retries: 5,
      factor: 1.5,
      minTimeout: 500,
      maxTimeout: 10 * 1000,
      randomize: false
    });
  };

  return DynamoQueue;

})();

S3Queue = (function() {
  function S3Queue(name, concurrency, timing) {
    this.name = name;
    this.timing = timing;
    this.push = __bind(this.push, this);
    this.queue = async.queue(function(task, callback) {
      return task(callback);
    }, concurrency);
  }

  S3Queue.prototype.push = function(fn, description, callback) {
    var operation,
      _this = this;

    operation = this._retryableOperation();
    return operation.attempt(function(currentAttempt) {
      var start;

      start = new Date().getTime();
      return _this.queue.push(fn, function(error, results) {
        var attempt, elapsed, retried;

        elapsed = new Date().getTime() - start;
        attempt = operation.attempts();
        if (_this._shouldRetry(error)) {
          retried = operation.retry(error);
        } else {
          retried = false;
        }
        if (retried) {
          return console.error('S3[#' + attempt + ',' + elapsed + 'ms] ' + _this.name + ': Retrying ' + description + ' due to ' + util.inspect(error));
        } else {
          if (_this.timing) {
            console.log('S3[#' + attempt + ',' + elapsed + 'ms] ' + _this.name + ': ' + description);
          }
          return callback(error, results);
        }
      });
    });
  };

  S3Queue.prototype._shouldRetry = function(error) {
    return true;
  };

  S3Queue.prototype._retryableOperation = function() {
    return retry.operation({
      retries: 5,
      factor: 1.5,
      minTimeout: 500,
      maxTimeout: 10 * 1000,
      randomize: false
    });
  };

  return S3Queue;

})();

BlobHandler = (function() {
  function BlobHandler(name, encodeFunction, decodeFunction, logging) {
    this.name = name;
    this.encodeFunction = encodeFunction;
    this.decodeFunction = decodeFunction;
    this.logging = logging;
    this.decode = __bind(this.decode, this);
    this.encode = __bind(this.encode, this);
  }

  BlobHandler.prototype.encode = function(data, callback) {
    var start,
      _this = this;

    start = new Date().getTime();
    return this.encodeFunction(data, function(error, result) {
      var elapsed, length;

      elapsed = new Date().getTime() - start;
      if (result != null) {
        length = result.length;
      } else {
        length = -1;
      }
      if (_this.logging) {
        console.log(_this.name + 'Blob:Compressed[' + data.length + ',' + length + ',' + elapsed + 'ms]');
      }
      return typeof callback === "function" ? callback(error, result) : void 0;
    });
  };

  BlobHandler.prototype.decode = function(data, callback) {
    var start,
      _this = this;

    start = new Date().getTime();
    return this.decodeFunction(data, function(error, result) {
      var elapsed, length;

      elapsed = new Date().getTime() - start;
      if (result != null) {
        length = result.length;
      } else {
        length = -1;
      }
      if (_this.logging) {
        console.log(_this.name + 'Blob:Decompressed[' + data.length + ',' + length + ',' + elapsed + 'ms]');
      }
      return typeof callback === "function" ? callback(error, result) : void 0;
    });
  };

  return BlobHandler;

})();

TextCompressor = (function() {
  function TextCompressor(compression, logging) {
    this.compression = compression;
    this.decode = __bind(this.decode, this);
    this.encode = __bind(this.encode, this);
    this.gzip = new BlobHandler('Base64Gzip', function(data, callback) {
      return zlib.gzip(new Buffer(data), callback);
    }, function(data, callback) {
      return zlib.gunzip(data, callback);
    }, logging);
    this.base64 = new BlobHandler('Base64', function(data, callback) {
      return typeof callback === "function" ? callback(null, new Buffer(data, 'binary').toString('base64')) : void 0;
    }, function(data, callback) {
      return typeof callback === "function" ? callback(null, new Buffer(data, 'base64')) : void 0;
    }, logging);
  }

  TextCompressor.prototype.encode = function(data, callback) {
    var _this = this;

    if (this.compression) {
      return this.gzip.encode(data, function(error, result) {
        return _this.base64.encode(result, callback);
      });
    } else {
      return typeof callback === "function" ? callback(null, data) : void 0;
    }
  };

  TextCompressor.prototype.decode = function(data, callback) {
    var _this = this;

    if (this.compression) {
      return this.base64.decode(data, function(error, result) {
        return _this.gzip.decode(result, callback);
      });
    } else {
      return typeof callback === "function" ? callback(null, data) : void 0;
    }
  };

  return TextCompressor;

})();

BinaryCompressor = (function() {
  function BinaryCompressor(compression, logging) {
    this.compression = compression;
    this.decode = __bind(this.decode, this);
    this.encode = __bind(this.encode, this);
    this.gzip = new BlobHandler('Gzip', function(data, callback) {
      return zlib.gzip(new Buffer(data), callback);
    }, function(data, callback) {
      return zlib.gunzip(data, callback);
    }, logging);
  }

  BinaryCompressor.prototype.encode = function(data, callback) {
    if (this.compression) {
      return this.gzip.encode(data, callback);
    } else {
      return typeof callback === "function" ? callback(null, data) : void 0;
    }
  };

  BinaryCompressor.prototype.decode = function(data, callback) {
    if (this.compression) {
      return this.gzip.decode(data, callback);
    } else {
      return typeof callback === "function" ? callback(null, data) : void 0;
    }
  };

  return BinaryCompressor;

})();

module.exports = AmazonDb = function(options) {
  var DynamoDB, S3, db, k, operations_ro_queue, operations_rw_queue, operations_table, s3, s3_ro_queue, s3_rw_queue, snapshots_bucket, snapshots_ro_queue, snapshots_rw_queue, snapshots_table, v, _ref;

  if (!(this instanceof AmazonDb)) {
    return new Db;
  }
  if (options == null) {
    options = {};
  }
  for (k in defaultOptions) {
    v = defaultOptions[k];
    if ((_ref = options[k]) == null) {
      options[k] = v;
    }
  }
  S3 = awssum.load('amazon/s3').S3;
  s3 = new S3({
    accessKeyId: options.amazon_access_key,
    secretAccessKey: options.amazon_secret_key,
    region: options.amazon_s3_region
  });
  DynamoDB = awssum.load('amazon/dynamodb').DynamoDB;
  db = new DynamoDB({
    accessKeyId: options.amazon_access_key,
    secretAccessKey: options.amazon_secret_key,
    region: options.amazon_dynamo_region
  });
  snapshots_table = options.amazon_dynamo_snapshots_table_name;
  snapshots_bucket = options.amazon_s3_snapshots_bucket_name;
  operations_table = options.amazon_dynamo_operations_table_name;
  s3_ro_queue = new S3Queue('read', options['s3_ro_concurrency'], options['timing']);
  s3_rw_queue = new S3Queue('write', options['s3_rw_concurrency'], options['timing']);
  snapshots_ro_queue = new DynamoQueue('snapshots read', options['snapshots_ro_concurrency'], options['timing']);
  snapshots_rw_queue = new DynamoQueue('snapshots write', options['snapshots_rw_concurrency'], options['timing']);
  operations_ro_queue = new DynamoQueue('operations read', options['operations_ro_concurrency'], options['timing']);
  operations_rw_queue = new DynamoQueue('operations write', options['operations_rw_concurrency'], options['timing']);
  this.create = function(docName, docData, callback) {
    var binaryCompressor, compressor;

    compressor = new TextCompressor(options['compress'], options['timing']);
    binaryCompressor = new BinaryCompressor(options['compress'], options['timing']);
    return async.auto({
      compress_meta: function(cb) {
        return compressor.encode(JSON.stringify(docData.meta), cb);
      },
      write_metadata: [
        'compress_meta', function(cb, results) {
          var request;

          request = {
            TableName: snapshots_table,
            Item: {
              doc: {
                S: docName
              },
              v: {
                N: docData.v.toString()
              },
              meta: {
                S: results.compress_meta
              },
              type: {
                S: docData.type
              },
              created_at: {
                N: new Date().getTime().toString()
              }
            },
            Expected: {
              doc: {
                Exists: false
              }
            }
          };
          if (options['compress']) {
            request.Item['c'] = {
              S: 't'
            };
          }
          return snapshots_rw_queue.push(function(c) {
            return db.PutItem(request, c);
          }, 'write Snapshot(' + docName + '-' + docData.v + ')', cb);
        }
      ],
      compress_data: function(cb) {
        return binaryCompressor.encode(JSON.stringify(docData.snapshot), cb);
      },
      write_data: [
        'compress_data', function(cb, results) {
          var params;

          params = {
            BucketName: snapshots_bucket,
            ObjectName: docName + '-' + docData.v + '.snapshot',
            ContentLength: results.compress_data.length,
            Body: results.compress_data
          };
          return s3_rw_queue.push(function(c) {
            return s3.PutObject(params, c);
          }, 'write Snapshot(' + docName + '-' + docData.v + ')', cb);
        }
      ]
    }, function(error, results) {
      if (error != null) {
        if ((error.Body != null) && error.Body.message.match('The conditional request failed')) {
          return typeof callback === "function" ? callback('Document already exists') : void 0;
        } else if ((results != null) && (results.write_metadata != null)) {
          console.error('Failed to save Snapshot(' + docName + '-' + docData.v + ') to S3: ' + util.inspect(error));
          return typeof callback === "function" ? callback('Failed to save snapshot to S3') : void 0;
        } else {
          console.error('Failed to save Snapshot(' + docName + '-' + docData.v + '): ' + util.inspect(error));
          return typeof callback === "function" ? callback('Failed to save snapshot') : void 0;
        }
      } else {
        return typeof callback === "function" ? callback() : void 0;
      }
    });
  };
  this["delete"] = function(docName, dbMeta, callback) {
    return async.auto({
      list_snapshots: function(cb) {
        var request;

        request = {
          TableName: snapshots_table,
          HashKeyValue: {
            S: docName
          },
          ScanIndexForward: false,
          ConsistentRead: true
        };
        return snapshots_ro_queue.push(function(c) {
          return db.Query(request, c);
        }, 'query Snapshots(' + docName + ')', cb);
      },
      list_operations: function(cb) {
        var request;

        request = {
          TableName: operations_table,
          HashKeyValue: {
            S: docName
          },
          ScanIndexForward: false,
          ConsistentRead: true
        };
        return operations_ro_queue.push(function(c) {
          return db.Query(request, c);
        }, 'query Operations(' + docName + ')', cb);
      },
      delete_snapshots: [
        'list_snapshots', function(cb, results) {
          if (results.list_snapshots.Body.Count === 0) {
            return cb('Document does not exist', null);
          }
          return async.mapSeries(results.list_snapshots.Body.Items, function(item, cb) {
            var request;

            request = {
              TableName: snapshots_table,
              Key: {
                HashKeyElement: {
                  S: item.doc.S
                },
                RangeKeyElement: {
                  N: item.v.N
                }
              },
              Expected: {
                doc: {
                  Value: {
                    S: item.doc.S
                  }
                }
              },
              ReturnValues: 'NONE'
            };
            return snapshots_rw_queue.push(function(c) {
              return db.DeleteItem(request, c);
            }, 'delete Snapshot(' + item.doc.S + '-' + item.v.N + ')', cb);
          }, function(error, result) {
            if (error != null) {
              return cb(error, null);
            } else {
              return cb(null, true);
            }
          });
        }
      ],
      delete_s3_snapshots: [
        'list_snapshots', function(cb, results) {
          if (results.list_snapshots.Body.Count === 0) {
            return cb(null, {});
          }
          return async.forEachSeries(results.list_snapshots.Body.Items, function(item, cb) {
            var params;

            params = {
              BucketName: snapshots_bucket,
              ObjectName: item.doc.S + '-' + item.v.N + '.snapshot'
            };
            return s3_rw_queue.push(function(c) {
              return s3.DeleteObject(params, c);
            }, 'delete Snapshot(' + item.doc.S + '-' + item.v.N + ')', cb);
          }, function(error) {
            if (error != null) {
              return cb(error, null);
            } else {
              return cb(null, true);
            }
          });
        }
      ],
      delete_operations: [
        'list_operations', function(cb, results) {
          if (results.list_operations.Body.Count === 0) {
            return cb(null, {});
          }
          return async.forEachSeries(results.list_operations.Body.Items, function(item, cb) {
            var request;

            request = {
              TableName: operations_table,
              Key: {
                HashKeyElement: {
                  S: item.doc.S
                },
                RangeKeyElement: {
                  N: item.v.N
                }
              },
              Expected: {
                doc: {
                  Value: {
                    S: item.doc.S
                  }
                }
              },
              ReturnValues: 'NONE'
            };
            return operations_rw_queue.push(function(c) {
              return db.DeleteItem(request, c);
            }, 'delete Operation(' + item.doc.S + '-' + item.v.N + ')', cb);
          }, function(error) {
            if (error != null) {
              return cb(error, null);
            } else {
              return cb(null, true);
            }
          });
        }
      ],
      delete_operations_s3: [
        'list_operations', function(cb, results) {
          if (results.list_operations.Body.Count === 0) {
            return cb(null, {});
          }
          return async.forEachSeries(results.list_operations.Body.Items, function(item, cb) {
            var params;

            if (item.e == null) {
              return cb(null, null);
            }
            params = {
              BucketName: snapshots_bucket,
              ObjectName: item.doc.S + '-' + item.v.N + '.operation'
            };
            return s3_rw_queue.push(function(c) {
              return s3.DeleteObject(params, c);
            }, 'delete Operation(' + item.doc.S + '-' + item.v.N + ')', cb);
          }, function(error) {
            if (error != null) {
              return cb(error, null);
            } else {
              return cb(null, true);
            }
          });
        }
      ]
    }, function(error, results) {
      if (error != null) {
        if ((error.Body != null) && error.Body.message.match('The conditional request failed')) {
          return typeof callback === "function" ? callback('Document does not exist') : void 0;
        } else if (error === 'Document does not exist') {
          return typeof callback === "function" ? callback(error) : void 0;
        } else {
          console.error('Failed to delete snapshots or operations from Document(' + docName + '): ' + util.inspect(error));
          return typeof callback === "function" ? callback('Failed to delete snapshots or operations') : void 0;
        }
      } else {
        return typeof callback === "function" ? callback(null) : void 0;
      }
    });
  };
  this.getSnapshot = function(docName, callback) {
    return async.auto({
      get_snapshot: function(cb) {
        var request;

        request = {
          TableName: snapshots_table,
          HashKeyValue: {
            S: docName
          },
          ScanIndexForward: false,
          Limit: 1,
          ConsistentRead: true
        };
        return snapshots_ro_queue.push(function(c) {
          return db.Query(request, c);
        }, 'query Snapshot(' + docName + ')', cb);
      },
      get_data: [
        'get_snapshot', function(cb, results) {
          var item, params;

          if (results.get_snapshot.Body.Count !== 1) {
            return cb('Document does not exist', null);
          }
          item = results.get_snapshot.Body.Items[0];
          params = {
            BucketName: snapshots_bucket,
            ObjectName: item.doc.S + '-' + item.v.N + '.snapshot'
          };
          return s3_ro_queue.push(function(c) {
            return s3.GetObject(params, c);
          }, 'fetch Snapshot(' + item.doc.S + '-' + item.v.N + ')', cb);
        }
      ],
      compressor: [
        'get_snapshot', 'get_data', function(cb, results) {
          return cb(null, {
            text: new TextCompressor(results.get_snapshot.Body.Items[0].c, options['timing']),
            binary: new BinaryCompressor(results.get_snapshot.Body.Items[0].c, options['timing'])
          });
        }
      ],
      snapshot: [
        'compressor', function(cb, results) {
          return results.compressor.binary.decode(results.get_data.Body, cb);
        }
      ],
      meta: [
        'compressor', function(cb, results) {
          return results.compressor.text.decode(results.get_snapshot.Body.Items[0].meta.S, cb);
        }
      ]
    }, function(error, results) {
      var data, item, meta, snapshot;

      if (error != null) {
        if (error === 'Document does not exist') {
          return typeof callback === "function" ? callback(error) : void 0;
        } else if ((results != null) && (results.get_snapshot != null)) {
          item = results.get_snapshot.Body.Items[0];
          console.error('Failed to get snapshot data for Document(' + item.doc.S + '-' + item.v.N + '): ' + util.inspect(error));
          return typeof callback === "function" ? callback('Failed to get snapshot data') : void 0;
        } else {
          console.error('Failed to get snapshot metadata for Document(' + docName + '): ' + util.inspect(error));
          return typeof callback === "function" ? callback('Failed to get snapshot metadata') : void 0;
        }
      } else {
        item = results.get_snapshot.Body.Items[0];
        try {
          snapshot = JSON.parse(results.snapshot);
        } catch (_error) {
          error = _error;
          snapshot = {};
          console.error('Failure: data was corrupt for Snapshot(' + docName + '-' + item.v.N + ')');
        }
        try {
          meta = JSON.parse(results.meta);
        } catch (_error) {
          error = _error;
          meta = {};
          console.error('Failure: metadata was corrupt for Snapshot(' + docName + '-' + item.v.N + ')');
        }
        data = {
          v: parseInt(item.v.N),
          snapshot: snapshot,
          type: item.type.S,
          meta: meta
        };
        return typeof callback === "function" ? callback(null, data) : void 0;
      }
    });
  };
  this.writeSnapshot = function(docName, docData, dbMeta, callback) {
    var binaryCompressor, compressor;

    compressor = new TextCompressor(options['compress'], options['timing']);
    binaryCompressor = new BinaryCompressor(options['compress'], options['timing']);
    return async.auto({
      compress_meta: function(cb) {
        return compressor.encode(JSON.stringify(docData.meta), cb);
      },
      write_metadata: [
        'compress_meta', function(cb, results) {
          var request;

          request = {
            TableName: snapshots_table,
            Item: {
              doc: {
                S: docName
              },
              v: {
                N: docData.v.toString()
              },
              meta: {
                S: results.compress_meta
              },
              type: {
                S: docData.type
              },
              created_at: {
                N: new Date().getTime().toString()
              }
            },
            Expected: {
              doc: {
                Exists: false
              }
            }
          };
          if (options['compress']) {
            request.Item['c'] = {
              S: 't'
            };
          }
          return snapshots_rw_queue.push(function(c) {
            return db.PutItem(request, c);
          }, 'write Snapshot(' + docName + '-' + docData.v + ')', cb);
        }
      ],
      compress_data: function(cb) {
        return binaryCompressor.encode(JSON.stringify(docData.snapshot), cb);
      },
      write_data: [
        'compress_data', function(cb, results) {
          var params;

          params = {
            BucketName: snapshots_bucket,
            ObjectName: docName + '-' + docData.v + '.snapshot',
            ContentLength: results.compress_data.length,
            Body: results.compress_data
          };
          return s3_rw_queue.push(function(c) {
            return s3.PutObject(params, c);
          }, 'write Snapshot(' + docName + '-' + docData.v + ')', cb);
        }
      ]
    }, function(error, results) {
      if (error != null) {
        if ((error.Body != null) && error.Body.message.match('The conditional request failed')) {
          return typeof callback === "function" ? callback('Document already exists') : void 0;
        } else if ((results != null) && (results.write_metadata != null)) {
          console.error('Failed to save Snapshot(' + docName + '-' + docData.v + ') to S3: ' + util.inspect(error));
          return typeof callback === "function" ? callback('Failed to save snapshot data') : void 0;
        } else {
          console.error('Failed to save Snapshot(' + docName + '-' + docData.v + '): ' + util.inspect(error));
          return typeof callback === "function" ? callback('Failed to save snapshot metadata') : void 0;
        }
      } else {
        return typeof callback === "function" ? callback() : void 0;
      }
    });
  };
  this.getOps = function(docName, start, end, callback) {
    if (end == null) {
      end = 2147483648;
    }
    if (start >= end) {
      return callback('Start must be less than end', []);
    }
    end = end - 1;
    return async.auto({
      get_metadata: function(cb) {
        var request;

        request = {
          TableName: operations_table,
          HashKeyValue: {
            S: docName
          },
          ConsistentRead: true,
          ComparisonOperator: 'BETWEEN',
          AttributeValueList: [
            {
              N: start.toString()
            }, {
              N: end.toString()
            }
          ]
        };
        return operations_ro_queue.push(function(c) {
          return db.Query(request, c);
        }, 'query Operations(' + docName + '-' + start + ':' + end + ')', cb);
      }
    }, function(error, results) {
      var data;

      if (error != null) {
        console.error('Failed to fetch Operations(' + docName + '-' + start + '..' + end + '): ' + util.inspect(error));
        return typeof callback === "function" ? callback('Failed to fetch operations') : void 0;
      } else {
        data = [];
        return async.map(results.get_metadata.Body.Items, function(operation, cb) {
          var compressor;

          compressor = new TextCompressor(operation.c != null, options['timing']);
          return async.auto({
            fetch_data: function(c) {
              var params;

              if (operation.e != null) {
                params = {
                  BucketName: snapshots_bucket,
                  ObjectName: docName + '-' + operation.v.N + '.operation'
                };
                return s3_ro_queue.push(function(d) {
                  return s3.GetObject(params, d);
                }, 'fetch Operation(' + docName + '-' + operation.v.N + ')', c);
              } else {
                return c(null, operation.op.S);
              }
            },
            data: [
              'fetch_data', function(c, r) {
                if (r.fetch_data.Body != null) {
                  return c(null, r.fetch_data.Body.toString());
                } else {
                  return c(null, r.fetch_data);
                }
              }
            ],
            snapshot: [
              'data', function(c, r) {
                return compressor.decode(r.data, c);
              }
            ],
            meta: function(c) {
              return compressor.decode(operation.meta.S, c);
            }
          }, function(error, results) {
            var item, meta, op;

            try {
              op = JSON.parse(results.snapshot);
            } catch (_error) {
              error = _error;
              op = {};
              console.error('Failure: data was corrupt for Operation(' + docName + '-' + operation.v.N + ')');
            }
            try {
              meta = JSON.parse(results.meta);
            } catch (_error) {
              error = _error;
              meta = {};
              console.error('Failure: metadata was corrupt for Operation(' + docName + '-' + operation.v.N + ')');
            }
            item = {
              op: op,
              meta: meta
            };
            return cb(null, item);
          });
        }, function(error, results) {
          return typeof callback === "function" ? callback(null, results) : void 0;
        });
      }
    });
  };
  this.writeOp = function(docName, opData, callback) {
    var compressor;

    compressor = new TextCompressor(options['compress'], options['timing']);
    return async.auto({
      compress_op: function(cb) {
        return compressor.encode(JSON.stringify(opData.op), cb);
      },
      compress_meta: function(cb) {
        return compressor.encode(JSON.stringify(opData.meta), cb);
      },
      request: [
        'compress_op', 'compress_meta', function(cb, results) {
          var request, request_too_large;

          request = {
            TableName: operations_table,
            Item: {
              doc: {
                S: docName
              },
              v: {
                N: opData.v.toString()
              },
              op: {
                S: results.compress_op
              },
              meta: {
                S: results.compress_meta
              }
            }
          };
          request_too_large = JSON.stringify(request).length > Math.pow(2, 16);
          if (request_too_large) {
            delete request.Item.op;
            request.Item['e'] = {
              S: 't'
            };
          }
          if (options['compress']) {
            request.Item['c'] = {
              S: 't'
            };
          }
          return cb(null, request);
        }
      ],
      write_metadata: [
        'request', function(cb, results) {
          return operations_rw_queue.push(function(c) {
            return db.PutItem(results.request, c);
          }, 'write Operation(' + docName + '-' + opData.v + ')', cb);
        }
      ],
      write_data: [
        'request', function(cb, results) {
          var params;

          if (!results.request.Item.e) {
            return cb(null, null);
          }
          params = {
            BucketName: snapshots_bucket,
            ObjectName: docName + '-' + opData.v + '.operation',
            ContentLength: results.compress_op.length,
            Body: results.compress_op
          };
          return s3_rw_queue.push(function(c) {
            return s3.PutObject(params, c);
          }, 'write Operation(' + docName + '-' + opData.v + ')', cb);
        }
      ]
    }, function(error, results) {
      if (error != null) {
        console.error('Failed to save Operation(' + docName + '-' + opData.v + '): ' + util.inspect(error));
        return typeof callback === "function" ? callback('Failure') : void 0;
      } else {
        return typeof callback === "function" ? callback() : void 0;
      }
    });
  };
  this.close = function() {};
  return this;
};
